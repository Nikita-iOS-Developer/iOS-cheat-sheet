#Начало работы с Git

##Инициализируем репозиторий

* git init - сделать папку репозиторием

Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать **Git-репозиторием**. Для этого следует переместиться в нее и ввести команду *git init*.

Пример:

```
$ cd ~/dev/first-project # перешли в нужную папку
$ git init # создали репозиторий 
```
* rm -rf .git - "разгитить" папку, если что-то пошло не так

Если случайно сделали Git-репозиторием не ту папку, ее можно "разгитить". Для этого нужно удалить скрытую подпапку .git

Пример

```
$ cd <папка с репозиторием> # перешли в папку
$ rm -rf .git # удалили подпапку .git
```

В подпапке .git хранится история изменений. Если удалить .git, то вся история проекта будет стерта без возможности восстановления - останется только последняя версия файлов.

* git status - показывавет текущее состояние репозитория

##Добавляем файлы в репозиторий

* git add --all - позволяет гиту отслеживать и хранить информацию **всех** файлов в репозитории. Добавлять файлы можно и по одному без ключа --all. Также можно добавить текущую папку целиком - в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке позволяет точка (.).

Пример:

```
#с ключом --all
git add --all # подготовили к сохранению все файлы в репозитории

#без ключа --all
$ git add todo.txt
$ git add readme.txt

#с ключом .
git add . # добавить всю текущую папку
```

##Делаем первый коммит

Коммит — это одна из основных сущностей в Git (и в других системах контроля версий). Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться».

* git commit -m - делает коммит, который присваивает сообщение этому коммиту

Пример:

```
#с ключом -m
git commit -m "Добавь первый коммит в репозиторий"
```

##Просматриваем историю коммитов

* git log - позволяет увидеть историю коммитов

##Синхронизируем локальный и удаленный репозитории

* git push - загружает содержимое локального репозитория на GitHub. В первый раз эту команду нужно вызывать с флагом -u и параметрами origin(имя удаленного репозитория) и main или master(название текущей ветки). Флаг -u свяжет локальную ветку с одноименной удаленной.

Пример:

```
git push -u origin main
```

##Файл README.md

Подробнее о файле README.md [Яндекс практикум](https://practicum.yandex.ru/trainer/git-basics/lesson/c6b9607c-e8bc-4446-89f9-c74522c3492f/)

##Исследуем лог

* git log - позволяет вывести описание коммитов. Чтобы получить сокращенное описание коммитов нужно ввести команду git log --oneline

##Файл HEAD

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый)

##Статусы файлов Git

###Статусы untracked/tracked, staged и modified

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом.

* untracked (англ. «неотслеживаемый») 
Новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.

* staged (англ. «подготовленный»)
После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.

* tracked (англ. «отслеживаемый») 
Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.

* modified (англ. «изменённый») 
Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

###Типичнвй жизненный цикл файла Git

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.
2. Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked). 
* Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked). Обратите внимание: staged и modified у одного файла, но у разных его версий.
* Ещё раз выполнили git add. Состояние: staged (+ tracked).
3. Сделали коммит с помощью git commit. Состояние: tracked.
4. Изменили файл. Состояние: modified (+ tracked).
5. Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).
6. Сделали коммит. Состояния: tracked.
7. Повторили пункты 4 - 7 много-много раз

##Как читать git status

Частая ошибка при использовании Git — закоммитить лишнее или, наоборот, забыть добавить важный файл в коммит. Этого легко избежать, если не забывать проверять статусы файлов с помощью команды git status.

###Какие состояния показывает git status

git status показывает только следующие состояния файлов:

* staged(Changes to be commited в выводу git status)
* modified(Changes not staged for commit)
* untracked(Untracked files)

##Как исправить коммит

* git commit --amend -- no-edit - позволяет добавить новые файлы в **последний закоммиченый файл**
* git commit --amend -m "Новое сообщение к коммиту" - позволяет заменить заголовок и описание коммита

##Как откатиться назад, если "все сломалось"

* git restore -- staged<sile> - команда, которая позволяет убрать файл из staging(после комманды git add). git restore --staged . - сбрасывает все файлы из staging обратно в untracked/modified.
* git reset --hard<commit hash> - возвращает состояние репозитория к более раннему. Все коммиты, файлы и код проекта которые были сделаны после коммита к которому мы вернулись удаляются **безвозвратно**!
* git restore<file> - возвращает файл(который не попал ни в staging ни в коммит) до последней версии, которая была сохранена через git commit или git add.


##Просматриваем изменения в файлах
* git diff - позволяет просмотреть изменения в файлах
По умолчанию команда git diff  не показывает изменения в staged-файлах - только в modified. Чтобы просмотреть изменения в staged, нужно использовать флаг --staged:

```
git diff --staged
```

###Сравниваем коммиты

* git diff<хэш 1 коммита> <хэш 2 коммита> - позволит сравнить два коммита


##Игнорирование файлов в Git

Часто бывает так, что в папке-репозитории есть файлы, для которых не нужно хранить историю изменений. Чтобы Git игнорировал такие файлы и не пытался добавить их в репозиторий, нужно создать файл .gitignore (от англ. ignore — «игнорировать») и записать в него названия игнорируемых файлов.

*Правила из .gitignore применяются только к новым (untracked) файлам. Если файл уже попал в staging area или в коммит, то правила на него не распространяются.*

Шаблоны:

* Если строка начинается с #, то это комментарий, и .gitignore не будет его учитывать.
* Если нужно, чтобы Git игнорировал все файлы .DS_Store. Для этого достаточно добавить в .gitignore строку с названием файла. В таком случае Git будет игнорировать файлы с именем .DS_Store, причём не только в корне репозитория, но и во всех вложенных папках.

```
.DS_Store
```

* Символ звёздочки (*) соответствует любой строке, включая пустую. Если такой символ используется в шаблоне в .gitignore, значит, файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки.

```
# игнорировать все файлы, которые заканчиваются на .jpeg
*.jpeg
# игнорировать все файлы "tmp" во всех подпапках папки docs
docs/*/tmp
```
Теперь Git будет игнорировать все файлы, которые заканчиваются на .jpeg — пригодится тем, кто не любит картинки. А также все временные файлы tmp (от англ. temporary — «временный») в подпапках папки docs. Например, Git проигнорирует файл docs/current/tmp.

* Вопросительный знак ? соответствует одному любому символу. 

```
file?.txt
```

Если сохранить такую запись в .gitignore, то будут проигнорированы, например, файлы fileA.txt и file1.txt. А вот файл file12.txt не будет проигнорирован, потому что в его названии два символа после file, а не один.

* Квадратные скобки, как и вопросительный знак, соответствуют одному символу. При этом символ не любой, а только из списка, который указан в скобках.

```
# игнорировать файлы file0.txt, file1.txt и file2.txt
# при этом не игнорировать file3.txt, file4.txt, ...
file[0-2].txt 
```

В скобках можно либо перечислить символы ([abc]), либо задать диапазон ([a-z]).

* Любое правило в файле .gitignore можно инвертировать с помощью восклицательного знака (!).

```
# игнорировать все JPEG-файлы
*.jpeg

# но только не мем с Doge
!doge.jpeg 
```

Теперь файл doge.jpeg будет отслеживаться, хотя остальные jpeg-файлы будут проигнорированы. Такие правила удобны для добавления исключений из других правил .gitignore.

###.gitignore и git status

Игнорируемые файлы не отображаются в выводе команды git status, иначе они бы засоряли вывод.
Если всё же нужно отобразить все игнорируемые файлы, то это можно сделать с помощью ключа --ignored: git status --ignored. В таком случае в выводе git status появится раздел Ignored files.
