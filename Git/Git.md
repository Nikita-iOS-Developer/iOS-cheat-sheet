# Начало работы с Git

## Инициализируем репозиторий

* git init - сделать папку репозиторием

Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать **Git-репозиторием**. Для этого следует переместиться в нее и ввести команду *git init*.

Пример:

```
$ cd ~/dev/first-project # перешли в нужную папку
$ git init # создали репозиторий 
```
* rm -rf .git - "разгитить" папку, если что-то пошло не так

Если случайно сделали Git-репозиторием не ту папку, ее можно "разгитить". Для этого нужно удалить скрытую подпапку .git

Пример

```
$ cd <папка с репозиторием> # перешли в папку
$ rm -rf .git # удалили подпапку .git
```

В подпапке .git хранится история изменений. Если удалить .git, то вся история проекта будет стерта без возможности восстановления - останется только последняя версия файлов.

* git status - показывавет текущее состояние репозитория

##Добавляем файлы в репозиторий

* git add --all - позволяет гиту отслеживать и хранить информацию **всех** файлов в репозитории. Добавлять файлы можно и по одному без ключа --all. Также можно добавить текущую папку целиком - в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке позволяет точка (.).

Пример:

```
#с ключом --all
git add --all # подготовили к сохранению все файлы в репозитории

#без ключа --all
$ git add todo.txt
$ git add readme.txt

#с ключом .
git add . # добавить всю текущую папку
```

## Делаем первый коммит

Коммит — это одна из основных сущностей в Git (и в других системах контроля версий). Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться».

* git commit -m - делает коммит, который присваивает сообщение этому коммиту

Пример:

```
#с ключом -m
git commit -m "Добавь первый коммит в репозиторий"
```

## Просматриваем историю коммитов

* git log - позволяет увидеть историю коммитов

## Синхронизируем локальный и удаленный репозитории

* git push - загружает содержимое локального репозитория на GitHub. В первый раз эту команду нужно вызывать с флагом -u и параметрами origin(имя удаленного репозитория) и main или master(название текущей ветки). Флаг -u свяжет локальную ветку с одноименной удаленной.

Пример:

```
git push -u origin main
```

## Файл README.md

Подробнее о файле README.md [Яндекс практикум](https://practicum.yandex.ru/trainer/git-basics/lesson/c6b9607c-e8bc-4446-89f9-c74522c3492f/)

## Исследуем лог

* git log - позволяет вывести описание коммитов. Чтобы получить сокращенное описание коммитов нужно ввести команду git log --oneline

## Файл HEAD

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый)

## Статусы файлов Git

### Статусы untracked/tracked, staged и modified

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом.

* untracked (англ. «неотслеживаемый») 
Новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.

* staged (англ. «подготовленный»)
После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.

* tracked (англ. «отслеживаемый») 
Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.

* modified (англ. «изменённый») 
Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

### Типичный жизненный цикл файла Git

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.
2. Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked). 
* Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked). Обратите внимание: staged и modified у одного файла, но у разных его версий.
* Ещё раз выполнили git add. Состояние: staged (+ tracked).
3. Сделали коммит с помощью git commit. Состояние: tracked.
4. Изменили файл. Состояние: modified (+ tracked).
5. Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).
6. Сделали коммит. Состояния: tracked.
7. Повторили пункты 4 - 7 много-много раз

## Как читать git status

Частая ошибка при использовании Git — закоммитить лишнее или, наоборот, забыть добавить важный файл в коммит. Этого легко избежать, если не забывать проверять статусы файлов с помощью команды git status.

### Какие состояния показывает git status

git status показывает только следующие состояния файлов:

* staged(Changes to be commited в выводу git status)
* modified(Changes not staged for commit)
* untracked(Untracked files)

## Как исправить коммит

* git commit --amend -- no-edit - позволяет добавить новые файлы в **последний закоммиченый файл**
* git commit --amend -m "Новое сообщение к коммиту" - позволяет заменить заголовок и описание коммита

## Как откатиться назад, если "все сломалось"

* git restore -- staged<sile> - команда, которая позволяет убрать файл из staging(после комманды git add). git restore --staged . - сбрасывает все файлы из staging обратно в untracked/modified.
* git reset --hard<commit hash> - возвращает состояние репозитория к более раннему. Все коммиты, файлы и код проекта которые были сделаны после коммита к которому мы вернулись удаляются **безвозвратно**!
* git restore<file> - возвращает файл(который не попал ни в staging ни в коммит) до последней версии, которая была сохранена через git commit или git add.


## Просматриваем изменения в файлах
* git diff - позволяет просмотреть изменения в файлах
По умолчанию команда git diff  не показывает изменения в staged-файлах - только в modified. Чтобы просмотреть изменения в staged, нужно использовать флаг --staged:

```
git diff --staged
```

### Сравниваем коммиты

* git diff<хэш 1 коммита> <хэш 2 коммита> - позволит сравнить два коммита


## Игнорирование файлов в Git

Часто бывает так, что в папке-репозитории есть файлы, для которых не нужно хранить историю изменений. Чтобы Git игнорировал такие файлы и не пытался добавить их в репозиторий, нужно создать файл .gitignore (от англ. ignore — «игнорировать») и записать в него названия игнорируемых файлов.

*Правила из .gitignore применяются только к новым (untracked) файлам. Если файл уже попал в staging area или в коммит, то правила на него не распространяются.*

Шаблоны:

* Если строка начинается с #, то это комментарий, и .gitignore не будет его учитывать.
* Если нужно, чтобы Git игнорировал все файлы .DS_Store. Для этого достаточно добавить в .gitignore строку с названием файла. В таком случае Git будет игнорировать файлы с именем .DS_Store, причём не только в корне репозитория, но и во всех вложенных папках.

```
.DS_Store
```

* Символ звёздочки (*) соответствует любой строке, включая пустую. Если такой символ используется в шаблоне в .gitignore, значит, файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки.

```
# игнорировать все файлы, которые заканчиваются на .jpeg
*.jpeg
# игнорировать все файлы "tmp" во всех подпапках папки docs
docs/*/tmp
```
Теперь Git будет игнорировать все файлы, которые заканчиваются на .jpeg — пригодится тем, кто не любит картинки. А также все временные файлы tmp (от англ. temporary — «временный») в подпапках папки docs. Например, Git проигнорирует файл docs/current/tmp.

* Вопросительный знак ? соответствует одному любому символу. 

```
file?.txt
```

Если сохранить такую запись в .gitignore, то будут проигнорированы, например, файлы fileA.txt и file1.txt. А вот файл file12.txt не будет проигнорирован, потому что в его названии два символа после file, а не один.

* Квадратные скобки, как и вопросительный знак, соответствуют одному символу. При этом символ не любой, а только из списка, который указан в скобках.

```
# игнорировать файлы file0.txt, file1.txt и file2.txt
# при этом не игнорировать file3.txt, file4.txt, ...
file[0-2].txt 
```

В скобках можно либо перечислить символы ([abc]), либо задать диапазон ([a-z]).

* Любое правило в файле .gitignore можно инвертировать с помощью восклицательного знака (!).

```
# игнорировать все JPEG-файлы
*.jpeg

# но только не мем с Doge
!doge.jpeg 
```

Теперь файл doge.jpeg будет отслеживаться, хотя остальные jpeg-файлы будут проигнорированы. Такие правила удобны для добавления исключений из других правил .gitignore.

### .gitignore и git status

Игнорируемые файлы не отображаются в выводе команды git status, иначе они бы засоряли вывод.
Если всё же нужно отобразить все игнорируемые файлы, то это можно сделать с помощью ключа --ignored: git status --ignored. В таком случае в выводе git status появится раздел Ignored files.

# Основы работы с ветками Git

## Клонируем репозиторий

Для того чтобы склонировать удаленный репозиторий на локальный компьютер необходимо:

1. Зайти на необходимый нам репозиторий в GitHub
2. Кнопка Code -> SSH -> копируем SSH
3. Открываем консоль, переходим с помощью команды cd в директорию, в которую хотим положить репозиторий, и выполняем команду git clone. Она создает копию удаленного репозитория на нашем компьютере. В качестве параметра команде нужно передать адрес репозитория, который мы только что скопировали на GitHub.

```
git clone https://github.com/.../...
# указываем адрес репозитория, который нужно склонировать 
```

Команда git clone автоматически связывает локальный и удалённый репозиторий. То есть если в GitHub-репозитории что-то поменяется (например, добавятся коммиты), нам не нужно будет заново клонировать его. Достаточно будет выполнить команду, которая обновит вашу копию.

## Выполняем Fork

Fork (англ. «развилка», «ответвление»), или «форк», — это GitHub-операция; напрямую с Git она не связана. «Форк» создаёт копию репозитория в аккаунте GitHub. Такая копия будет полностью независима. Изменения, которые мы внесём, не будут синхронизированы с исходным репозиторием.

В процессе «форка» создаётся копия всех файлов, истории коммитов и веток. Эта копия сохраняется в нашей учётной записи GitHub.

Для того чтобы выполнить форк необходимо:

1. Переходим на страницу нужного нам репозитория в GitHub.
2. Нажимаем на кнопку Fork -> если нужно меняем название и жмем Create fork
3. Если нужно то клонируем репозиторий на локальный компьютер

## Ветки

* git branch - выводит ветки, которые есть в проекте. Звездочкой (*) отмечено, в какой ветке мы находимся в текущий момент.
* git branch <название новой ветки> - команда создает новую ветку
* git checkout <название ветки на которую хотим переключиться> - переходим на указанную ветку в команде
* git checkout -b <название новой ветки> - создает новую ветку и сразу переключает на нее

Чтобы сравнить одно ветку с другой на поможет команда git diff:
* git diff <название 1 ветки> <название 2 ветки> - сравнивает две указанные ветки в команде друг с другом. При сравнении мы также можем использовать название ветки и хеш коммита.

## Суффикс навигации ~

Сравнивать хеши комитов может быть неудобно, ведь в одной ветке их может быть много. Представим: сначала мы выводим историю через git log, затем ищем в длинном списке хеши тех коммитов, которые хотите сравнить, и только потом выполняем git diff.
Для облегчения этой задачи в Git есть суффикс навигации ~n, где n — это число. Он отсчитывает от заданного коммита n коммитов назад во времени. Нумерация начинается с нуля: commit~0 — это сам коммит, commit~1 — предыдущий, commit~2 — предшествующий предыдущему и так далее.
Например, HEAD~1 — это следующий за текущим коммит. А main~5 — это пятый коммит в ветке main, если считать с последнего выполненного коммита.
На практике чаще нужен либо текущий коммит (HEAD), либо следующий за ним (HEAD~1). Для ~1 есть специальное сокращение ~ (без числа). То есть вместо HEAD~1 обычно пишут просто HEAD~.

Например:

```
# Чтобы вывести разницу между предыдущим и текущим коммитами, выполним следующую команду.
git diff HEAD~ HEAD

# Или то же самое, но через ~N.
git diff feature/diff~1 feature/diff

# Или можно использовать хеши
git diff 2ea56ab~ 2ea56ab
```

## Объединяем и удаляем ветки

Перед тем как начать процесс слияния, нужно перейти в ветку, куда должны добавиться изменения. Обычно это главная ветка.

* git merge <название ветки которую хотим объединить с главной веткой> - объединяет ветки. Если мы находимся например в главной ветке(main) то она получит всю информацию из дочерней ветки.
* git branch -D <название ветки которую хотим удалить> - удаляет ветку. У команды git branch -D есть более безопасный вариант с флагом -d. Он удалит ветку только если она была полностью объединена с другой — то есть если две ветки стали (или изначально были) частью одной истории. Например, если мы нечаянно создали ветку с неправильным названием, её можно удалить через git branch -d <имя ветки>.

*Удаление локальной ветки через Git не удаляет ветку на GitHub*

## Конфликты

Если Git не может провести слияние изменений автоматически, он сообщает о конфликте. Конфликт — это ситуация, в которой один или несколько человек модифицировали один и тот же файл. При этом результаты таких модификаций оказались несовместимы и разобраться в том, какой из вариантов правильный, может только человек.
В разработке, например, конфликты чаще всего возникают, когда несколько программистов одновременно меняют код в одном и том же месте.

### Как разрешить конфликты: общие рекомендации

Во время слияния Git сам подсвечивает файлы, которые не смог объединить. Чтобы разобраться в ситуации, нужно сделать следующее:
1. Заглянуть в файл, где произошёл конфликт.
2. Изучить обе стороны конфликта — вашу версию и версию вашего коллеги. Ваша задача — правильно собрать две версии в итоговую, так чтобы изменения обеих сторон не потерялись. Новая версия станет текущей актуальной.
3. Вручную удалить или подправить неактуальные изменения, если они есть.
4. Подготовить изменения к сохранению и сделать коммит.

## Забираем изменения из удаленного репозитория

* git pull - скачать изменения из удаленного репозитория

Алгоритм такой. Сначала нужно перейти в локальный репозиторий и убедиться, что мы находимся в правильной ветке, — как правило, это основная ветка main (или master). Затем можно ввести команду git pull.
Дополнительно git pull и git merge выполняют перед тем, как создать пул-реквест. При командной работе, особенно в больших командах, основная ветка часто успевает «убежать» вперёд, пока мы подготавливаем свои изменения. Поэтому перед созданием пул-реквеста рекомендуется сначала подтянуть изменения из основной ветки, объединить их с нашей, решить все возможные конфликты и лишь затем сделать push.

```
$ git checkout main # перешли в main
$ git pull # подтянули новые изменения в main
$ git checkout my-branch # вернулись в рабочую ветку my-branch
$ git merge main # влили main в новую ветку my-branch
$ git push -u origin my-branch # отправили ветку my-branch в удалённый репозиторий
```

# Продвинутая командная работа с Git

## Что такое fast-forward

Две ветки находятся в состоянии fast-forward, если одну из них можно «перемотать» вперёд и она будет содержать те же коммиты, что и другая. Это утверждение можно сформулировать иначе:
* при слиянии этих двух веток никак не возможен конфликт;
* истории этих двух веток не «разошлись»;
* одна ветка является продолжением другой.

Разберём на примере. Есть две ветки: main и add-docs (англ. «добавить документацию»). В ветке main четыре коммита, от неё создали ветку add-docs и добавили в неё ещё два коммита.

```
$ git branch
* add-docs
  main

$ git log --oneline
e08fa2a (HEAD -> add-docs) New docs 2
fd588b2 New docs 1
997d9ce (main) Commit 4
0313e8e Commit 3
5848aba Commit 2
04923d7 Commit 1
```

Ветка add-docs «обгоняет» ветку main на два коммита. Допустим, мы хотим влить ветку add-docs в main. При этом все коммиты из add-docs можно просто «положить» в main, и они выстроятся за уже существующими.
Результат слияния будет выглядеть так:

```
$ git checkout main
$ git merge add-docs
Updating 997d9ce..e08fa2a
Fast-forward
 docs.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 docs.txt

$ git log --oneline
e08fa2a (HEAD -> main, add-docs) New docs 2
fd588b2 New docs 1
997d9ce Commit 4
0313e8e Commit 3
5848aba Commit 2
04923d7 Commit 1
```

Обращаем внимание на два момента:
* При слиянии веток Git выводит строку Fast-forward.
* В истории коммитов HEAD указывает одновременно и на main, и на add-docs. После такого слияния эти ветки одинаковые: в них одни и те же коммиты.

Git просто добавил коммиты из add-docs в ветку main, или перемотал main вперёд до состояния add-docs. Отсюда и название «перемотка».

## Можно ли отключить fast-forward

Fast-forward слияние веток можно отключить флагом --no-ff. Например: git merge --no-ff add-docs. Также его можно отключить «навсегда» (до тех пор, пока мы не вернем настройку «как было») с помощью настройки merge.ff: git config [--global] merge.ff false.
Если отключить слияние в режиме fast-forward, вместо «перемотки» ветки Git создаст в ней коммит слияния (англ. merge commit) — в обиходе его называют merge-коммит или мёрж-коммит. В этом случае результат «вливания» ветки add-docs в main выглядел бы так:

```
# находимся в ветке main
# --no-edit отключает ввод сообщения для merge-коммита
# --no-ff отключает fast-forward слияние веток
$ git merge --no-edit --no-ff add-docs
Merge made by the 'ort' strategy.
 docs.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 docs.txt

# с флагом --graph
# Git нарисует ветки с помощью «палочек» и «звёздочек»
# получившийся коммит слияния: 6814789
$ git log --graph --oneline
*   6814789 (HEAD -> main) Merge branch 'add-docs'
|\
| * e08fa2a (add-docs) New docs 2
| * fd588b2 New docs 1
|/
* 997d9ce Commit 4
* 0313e8e Commit 3
* 5848aba Commit 2
* 04923d7 Commit 1
```

# Non-fast-forward

## Состояние non-fast-forward

Вернёмся к примеру с ветками main и add-docs и представим такую ситуацию: истории двух веток «разошлись». Это значит, что их коммиты уже нельзя выстроить в одну линию.
Например, после «отделения» add-docs в ветку main добавили новый коммит Commit 5:

```
# команде git log можно указать несколько веток, и тогда она выведет их все
$ git log --graph --oneline main add-docs
* 15d3f04 (HEAD -> main) Commit 5
| * 8de42eb (add-docs) New docs 2
| * 4d3c346 New docs 1
|/
* 73def1e Commit 4
* 9c30ab3 Commit 3
* 83cc5ec Commit 2
* 8e87fb2 Commit 1
```

Теперь просто «положить» все коммиты из add-docs в main не получится. Например, коммит 5 из main  может конфликтовать с каким-нибудь коммитом из ветки add-docs. То есть содержать изменения в тех же файлах (и в тех же строках), что и коммит 5.

При слиянии не-fast-forward веток Git создаёт коммит слияния:

```
# находимся в ветке main
# --no-edit избавляет от необходимости вводить сообщение для merge-коммита
$ git merge --no-edit add-docs
Merge made by the 'ort' strategy.
 docs.txt | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 docs.txt

# коммит слияния: 34f5f8f
$ git log --graph --oneline
*   34f5f8f (HEAD -> main) Merge branch 'add-docs'
|\
| * 8de42eb (add-docs) New docs 2
| * 4d3c346 New docs 1
* | 15d3f04 Commit 5
|/
* 73def1e Commit 4
* 9c30ab3 Commit 3
* 83cc5ec Commit 2
* 8e87fb2 Commit 1
```

Если конфликтов при слиянии нет, команда git merge отработает почти автоматически — только предложит нам ввести сообщение для нового коммита слияния.

*Чаще всего сообщения к коммитам слияния не редактируют и оставляют «как предложил Git». Для таких случаев удобен флаг --no-edit: git merge --no-edit <дочерняя ветка>.*

##Разрешение конфликта#

Ссылки на материал по разрешению конфликтов:
[В ручную или vimdiff] (https://practicum.yandex.ru/trainer/git-basics/lesson/df8f8fed-e3f8-44bd-90e4-3e67bc02e507/)
[Visual Studio Code] (https://practicum.yandex.ru/trainer/git-basics/lesson/653d1bce-8700-46db-8ddd-cf39a0575a1f/)
