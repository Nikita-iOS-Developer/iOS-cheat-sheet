#Начало работы с Git

##Инициализируем репозиторий

* git init - сделать папку репозиторием

Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать **Git-репозиторием**. Для этого следует переместиться в нее и ввести команду *git init*.

Пример:

```
$ cd ~/dev/first-project # перешли в нужную папку
$ git init # создали репозиторий 
```
* rm -rf .git - "разгитить" папку, если что-то пошло не так

Если случайно сделали Git-репозиторием не ту папку, ее можно "разгитить". Для этого нужно удалить скрытую подпапку .git

Пример

```
$ cd <папка с репозиторием> # перешли в папку
$ rm -rf .git # удалили подпапку .git
```

В подпапке .git хранится история изменений. Если удалить .git, то вся история проекта будет стерта без возможности восстановления - останется только последняя версия файлов.

* git status - показывавет текущее состояние репозитория

##Добавляем файлы в репозиторий

* git add --all - позволяет гиту отслеживать и хранить информацию **всех** файлов в репозитории. Добавлять файлы можно и по одному без ключа --all. Также можно добавить текущую папку целиком - в этом случае все файлы в ней тоже будут добавлены. Обратиться к текущей папке позволяет точка (.).

Пример:

```
#с ключом --all
git add --all # подготовили к сохранению все файлы в репозитории

#без ключа --all
$ git add todo.txt
$ git add readme.txt

#с ключом .
git add . # добавить всю текущую папку
```

##Делаем первый коммит

Коммит — это одна из основных сущностей в Git (и в других системах контроля версий). Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться».

* git commit -m - делает коммит, который присваивает сообщение этому коммиту

Пример:

```
#с ключом -m
git commit -m "Добавь первый коммит в репозиторий"
```

##Просматриваем историю коммитов

* git log - позволяет увидеть историю коммитов

##Синхронизируем локальный и удаленный репозитории

* git push - загружает содержимое локального репозитория на GitHub. В первый раз эту команду нужно вызывать с флагом -u и параметрами origin(имя удаленного репозитория) и main или master(название текущей ветки). Флаг -u свяжет локальную ветку с одноименной удаленной.

Пример:

```
git push -u origin main
```

##Файл README.md

Подробнее о файле README.md [Яндекс практикум](https://practicum.yandex.ru/trainer/git-basics/lesson/c6b9607c-e8bc-4446-89f9-c74522c3492f/)

##Исследуем лог

* git log - позволяет вывести описание коммитов. Чтобы получить сокращенное описание коммитов нужно ввести команду git log --oneline

##Файл HEAD

Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый)

##Статусы файлов Git

###Статусы untracked/tracked, staged и modified

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом.

* untracked (англ. «неотслеживаемый») 
Новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.

* staged (англ. «подготовленный»)
После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.

* tracked (англ. «отслеживаемый») 
Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.

* modified (англ. «изменённый») 
Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

###Типичнвй жизненный цикл файла Git

1. Файл только что создали. Git ещё не отслеживает содержимое этого файла. Состояние: untracked.
2. Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked). 
* Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked). Обратите внимание: staged и modified у одного файла, но у разных его версий.
* Ещё раз выполнили git add. Состояние: staged (+ tracked).
3. Сделали коммит с помощью git commit. Состояние: tracked.
4. Изменили файл. Состояние: modified (+ tracked).
5. Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked).
6. Сделали коммит. Состояния: tracked.
7. Повторили пункты 4 - 7 много-много раз

##Как читать git status

Частая ошибка при использовании Git — закоммитить лишнее или, наоборот, забыть добавить важный файл в коммит. Этого легко избежать, если не забывать проверять статусы файлов с помощью команды git status.

###Какие состояния показывает git status

git status показывает только следующие состояния файлов:

* staged(Changes to be commited в выводу git status)
* modified(Changes not staged for commit)
* untracked(Untracked files)

##Как исправить коммит

* git commit --amend -- no-edit - позволяет добавить новые файлы в **последний закоммиченый файл**
* git commit --amend -m "Новое сообщение к коммиту" - позволяет заменить заголовок и описание коммита

##Как откатиться назад, если "все сломалось"

* git restore -- staged<sile> - команда, которая позволяет убрать файл из staging(после комманды git add). git restore --staged . - сбрасывает все файлы из staging обратно в untracked/modified.
* git reset --hard<commit hash> - возвращает состояние репозитория к более раннему. Все коммиты, файлы и код проекта которые были сделаны после коммита к которому мы вернулись удаляются **безвозвратно**!
* git restore<file> - возвращает файл(который не попал ни в staging ни в коммит) до последней версии, которая была сохранена через git commit или git add.


##Просматриваем изменения в файлах
* git diff - позволяет просмотреть изменения в файлах
По умолчанию команда git diff  не показывает изменения в staged-файлах - только в modified. Чтобы просмотреть изменения в staged, нужно использовать флаг --staged:

```
git diff --staged
```

###Сравниваем коммиты

* git diff<хэш 1 коммита> <хэш 2 коммита> - позволит сравнить два коммита


##Игнорирование файлов в Git

Часто бывает так, что в папке-репозитории есть файлы, для которых не нужно хранить историю изменений. Чтобы Git игнорировал такие файлы и не пытался добавить их в репозиторий, нужно создать файл .gitignore (от англ. ignore — «игнорировать») и записать в него названия игнорируемых файлов.

*Правила из .gitignore применяются только к новым (untracked) файлам. Если файл уже попал в staging area или в коммит, то правила на него не распространяются.*

Шаблоны:

* Если строка начинается с #, то это комментарий, и .gitignore не будет его учитывать.
* Если нужно, чтобы Git игнорировал все файлы .DS_Store. Для этого достаточно добавить в .gitignore строку с названием файла. В таком случае Git будет игнорировать файлы с именем .DS_Store, причём не только в корне репозитория, но и во всех вложенных папках.

```
.DS_Store
```

* Символ звёздочки (*) соответствует любой строке, включая пустую. Если такой символ используется в шаблоне в .gitignore, значит, файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки.

```
# игнорировать все файлы, которые заканчиваются на .jpeg
*.jpeg
# игнорировать все файлы "tmp" во всех подпапках папки docs
docs/*/tmp
```
Теперь Git будет игнорировать все файлы, которые заканчиваются на .jpeg — пригодится тем, кто не любит картинки. А также все временные файлы tmp (от англ. temporary — «временный») в подпапках папки docs. Например, Git проигнорирует файл docs/current/tmp.

* Вопросительный знак ? соответствует одному любому символу. 

```
file?.txt
```

Если сохранить такую запись в .gitignore, то будут проигнорированы, например, файлы fileA.txt и file1.txt. А вот файл file12.txt не будет проигнорирован, потому что в его названии два символа после file, а не один.

* Квадратные скобки, как и вопросительный знак, соответствуют одному символу. При этом символ не любой, а только из списка, который указан в скобках.

```
# игнорировать файлы file0.txt, file1.txt и file2.txt
# при этом не игнорировать file3.txt, file4.txt, ...
file[0-2].txt 
```

В скобках можно либо перечислить символы ([abc]), либо задать диапазон ([a-z]).

* Любое правило в файле .gitignore можно инвертировать с помощью восклицательного знака (!).

```
# игнорировать все JPEG-файлы
*.jpeg

# но только не мем с Doge
!doge.jpeg 
```

Теперь файл doge.jpeg будет отслеживаться, хотя остальные jpeg-файлы будут проигнорированы. Такие правила удобны для добавления исключений из других правил .gitignore.

###.gitignore и git status

Игнорируемые файлы не отображаются в выводе команды git status, иначе они бы засоряли вывод.
Если всё же нужно отобразить все игнорируемые файлы, то это можно сделать с помощью ключа --ignored: git status --ignored. В таком случае в выводе git status появится раздел Ignored files.

#Основы работы с ветками Git

##Клонируем репозиторий

Для того чтобы склонировать удаленный репозиторий на локальный компьютер необходимо:

1. Зайти на необходимый нам репозиторий в GitHub
2. Кнопка Code -> SSH -> копируем SSH
3. Открываем консоль, переходим с помощью команды cd в директорию, в которую хотим положить репозиторий, и выполняем команду git clone. Она создает копию удаленного репозитория на нашем компьютере. В качестве параметра команде нужно передать адрес репозитория, который мы только что скопировали на GitHub.

```
git clone https://github.com/.../...
# указываем адрес репозитория, который нужно склонировать 
```

Команда git clone автоматически связывает локальный и удалённый репозиторий. То есть если в GitHub-репозитории что-то поменяется (например, добавятся коммиты), нам не нужно будет заново клонировать его. Достаточно будет выполнить команду, которая обновит вашу копию.

##Выполняем Fork

Fork (англ. «развилка», «ответвление»), или «форк», — это GitHub-операция; напрямую с Git она не связана. «Форк» создаёт копию репозитория в аккаунте GitHub. Такая копия будет полностью независима. Изменения, которые мы внесём, не будут синхронизированы с исходным репозиторием.

В процессе «форка» создаётся копия всех файлов, истории коммитов и веток. Эта копия сохраняется в нашей учётной записи GitHub.

Для того чтобы выполнить форк необходимо:

1. Переходим на страницу нужного нам репозитория в GitHub.
2. Нажимаем на кнопку Fork -> если нужно меняем название и жмем Create fork
3. Если нужно то клонируем репозиторий на локальный компьютер

##Ветки

* git branch - выводит ветки, которые есть в проекте. Звездочкой (*) отмечено, в какой ветке мы находимся в текущий момент.
* git branch <название новой ветки> - команда создает новую ветку
* git checkout <название ветки на которую хотим переключиться> - переходим на указанную ветку в команде
* git checkout -b <название новой ветки> - создает новую ветку и сразу переключает на нее

Чтобы сравнить одно ветку с другой на поможет команда git diff:
* git diff <название 1 ветки> <название 2 ветки> - сравнивает две указанные ветки в команде друг с другом. При сравнении мы также можем использовать название ветки и хеш коммита.

##Суффикс навигации ~

Сравнивать хеши комитов может быть неудобно, ведь в одной ветке их может быть много. Представим: сначала мы выводим историю через git log, затем ищем в длинном списке хеши тех коммитов, которые хотите сравнить, и только потом выполняем git diff.
Для облегчения этой задачи в Git есть суффикс навигации ~N, где N — это число. Он отсчитывает от заданного коммита N коммитов назад во времени. Нумерация начинается с нуля: commit~0 — это сам коммит, commit~1 — предыдущий, commit~2 — предшествующий предыдущему и так далее.
Например, HEAD~1 — это следующий за текущим коммит. А main~5 — это пятый коммит в ветке main, если считать с последнего выполненного коммита.
На практике чаще нужен либо текущий коммит (HEAD), либо следующий за ним (HEAD~1). Для ~1 есть специальное сокращение ~ (без числа). То есть вместо HEAD~1 обычно пишут просто HEAD~.

Например:

```
# Чтобы вывести разницу между предыдущим и текущим коммитами, выполним следующую команду.
git diff HEAD~ HEAD

# Или то же самое, но через ~N.
git diff feature/diff~1 feature/diff

# Или можно использовать хеши
git diff 2ea56ab~ 2ea56ab
```

##Объединяем и удаляем ветки

Перед тем как начать процесс слияния, нужно перейти в ветку, куда должны добавиться изменения. Обычно это главная ветка.

* git merge <название ветки которую хотим объединить с главной веткой> - объединяет ветки. Если мы находимся например в главной ветке(main) то она получит всю информацию из дочерней ветки.
* git branch -D <название ветки которую хотим удалить> - удаляет ветку. У команды git branch -D есть более безопасный вариант с флагом -d. Он удалит ветку только если она была полностью объединена с другой — то есть если две ветки стали (или изначально были) частью одной истории. Например, если мы нечаянно создали ветку с неправильным названием, её можно удалить через git branch -d <имя ветки>.

*Удаление локальной ветки через Git не удаляет ветку на GitHub*

##Конфликты

Если Git не может провести слияние изменений автоматически, он сообщает о конфликте. Конфликт — это ситуация, в которой один или несколько человек модифицировали один и тот же файл. При этом результаты таких модификаций оказались несовместимы и разобраться в том, какой из вариантов правильный, может только человек.
В разработке, например, конфликты чаще всего возникают, когда несколько программистов одновременно меняют код в одном и том же месте.

###Как разрешить конфликты: общие рекомендации

Во время слияния Git сам подсвечивает файлы, которые не смог объединить. Чтобы разобраться в ситуации, нужно сделать следующее:
1. Заглянуть в файл, где произошёл конфликт.
2. Изучить обе стороны конфликта — вашу версию и версию вашего коллеги. Ваша задача — правильно собрать две версии в итоговую, так чтобы изменения обеих сторон не потерялись. Новая версия станет текущей актуальной.
3. Вручную удалить или подправить неактуальные изменения, если они есть.
4. Подготовить изменения к сохранению и сделать коммит.

