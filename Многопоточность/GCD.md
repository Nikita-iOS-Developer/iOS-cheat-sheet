# Grand Central Dispatch

Grand Central Dispatch (GCD) - это фреймворк в iOS и macOS, предоставляющий удобные средства для управления параллельным выполнением задач. GCD позволяет разработчикам создавать и запускать задачи асинхронно, управлять очередями выполнения, контролировать приоритеты задач и обеспечивать безопасный доступ к данным из разных потоков.

Основные концепции GCD:

1. **Очереди (Queues)**: GCD использует очереди для организации и управления задачами. Есть два типа очередей - серийные (serial) и параллельные (concurrent). Серийные очереди выполняют задачи последовательно, а параллельные - одновременно.
Примеры очередей:

```
    DispatchQueue.main - serial очередь
    
    DispatchQueue.global() - concurrent очередь
```
Пример задачь в serial  и concurrent очередях:

```
    @IBAction func buttonOneAction(_ sender: UIButton) {
        testLabelOutlet.text = ""
        for i in 1...1000 {
            DispatchQueue.global(qos: .userInitiated).async {
                print(i)
            }
        }
    }

```

В примере выше мы накидываем 1000 задачь в concurent очередь. Числа от 1 до 1000 имитируют задачи и эти задачи будут выводиться в случайном порядке: 2,32,66 и т.д. Если бы вместо global был бы main, то задачи(числа) выводились бы в последовательном порядке т.е пока не выполнится первая задача, другая выполняться не будет: 1,2,3 и т.д.
2. **Задачи (Tasks)**: Задачи в GCD представляют собой блоки кода, которые нужно выполнить. Задачи могут быть синхронными (блокирующие текущий поток выполнения) или асинхронными (выполняются в фоновом режиме).
Пример задачь в concurrent очередях в ассинхронном режиме:

```
    @IBAction func buttonTwoAction(_ sender: UIButton) {
        DispatchQueue.global(qos: .userInitiated).async {
            print(self.fivonachi(45))
        }
        
        DispatchQueue.global(qos: .userInitiated).async {
            print(self.fivonachi(30)) --> выполнится быстрее
        }
    }
    
    // При нажатии на кнопку buttonTwoAction интерфейс пользователя НЕ заблокируется так как задачи выполняются ассинхронно, но результат придет через время.
    // Синхронная задача заблокирует интерфейс до тех пор пока не выполнит задачу.
    
```

3. **Группы (Groups)**: Группы позволяют объединять несколько задач и отслеживать их завершение.

Под капотом GCD работает на Threads. С GCD нужно перестать оперировать понятием потока(thread), а следует рассматривать понятие очередь(queue).

## Quality of Service (QoS)

Если мы решили сделать чтото параллельно от UI например скачать картинку, мы должны решить в каком типе QoS нам нужно сделать запрос на сервер. Т.е насколько быстро эта задача должна выполниться

* User-interactive - это представляет собой задачи, которые необходимо выполнить немедленно, чтобы обеспечить приятный пользовательский интерфейс. Используем это для обновлений пользовательского интерфеса, обработки событий и небольших нашрузок, требующей низкой задержки. Общий объем работы, выполненной в этой очереди во время выполнения нашего приложения, должен быть небольшим.
* User-initiated - представляет задачи, которые инициируются из пользовательского интерфейса и могут выполняться асинхронно. Т.е пользователь чтото инициировал и ждет ответа.
* default - задачи на этой очереди имеют стандартный приоритет выполнения. Обычно он используется в главном потоке, так как он обрабатывает пользовательский интерфейс и другие задачи среднего приоритета.
* Utility - это долгоиграющие хадачи, обычно с индикатором прогресса, видимым пользователем. Используем его для вычислений, ввода-вывода, сетей, непрерывных каналов передачи данных и аналогичных задач. Этот класс предназначен для обеспечения энергоэффективности.
* Background - это задачи, которых пользователь не знает. Используем его для предварительной загрузки, обслуживания и других задач, которые не требуют взаимодействия с пользователем и не зависят от времени.

## Очередь + Задача

В очередь задачу можно добавить несколькими способами:
1. async - неблокирующий вызов, возврат из метода "сразу", блок выполнения "чуть позже". async не будет дожидаться старта и конца замыкания, а сразу выйдет из него. Тело замыкания выполнится "позже".
2. sync - дожидается выполнения блока, можем получить возвращаемое значение из блока. Без веской причины sync не должен использоваться. sync может создать deadlock. sync дожидается когда работа в блоке выполнится и только тогда он выйдет из замыкания.

Очереди в GCD бывают разные:
1. Serial - все задачи выполняются строго последовательно. Каждая следующая задача начнет выполняться после того как выполнится текущая задача. Пример serial очередь - main. Каждый блок в serial щчереди выполняется последовательно, а это значит что они не пересекутся что является удобным механизмом для синхронизации (не будет Data Race - это ситуация в параллельном программировании, когда два или более потока одновременно обращаются к общей памяти и хотя бы один из них выполняет операцию записи.)
Main Queue - важная вещь, так как там происходит UI. Все задачи которые мы добавляем в Main Queue выполняются в главном потоке. Другие serial очереди не гарантируют того что задача будет выполняться на одном и том же потоке(есть гарантия что задачи будут выполняться последовательно). В main  queue рекомендуется не использовать sync.
2. Concurrent - задачи выполняются параллельно друг другу(одновременно). Завершение задачи будет зависеть от самого блока. В системе есть стандартные очереди с различными QoS куда мы можем добавить наши задачи. Можно создать свою очередь, но без веской причины лучше этого не делать.

## Получение очередей

let mainQueue = DispatchQueue.main
let backgroundQueue = DispatchQueue.global(qos: DispatchQoS)
DispatchQoS.userInteractive
DipatchQoS.userInitiated
DispatchQoS.background
DispatchQoS.utility

Создание очередей:

let serialQueue = DispatchQueue(label: "my_queue1")
let concurentQueue = DispatchQueue(label: "my_queue2", attributes: .concurent)

## Выполнение задачи с задержкой

Если нам нужно отправить задачу с задержкой в очередь:

DispatchQueue.main.asyncAfter(deadline: .now() + delayInSeconds) {
    //code
}
