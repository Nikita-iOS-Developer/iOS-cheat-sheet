# Threads

Все операции, выполняемые в мобильном приложении, требуют некоторых ресурсов и имеют время на выполнение. Эти операции по умолчанию выполняются поочередно на главном потоке.

*Потоки - это одна из технологий, которые позволяют выполнять несколько операций внутри одного приложения одновременно. Хотя новые технологии, такие как Operations и Grand Central Dispatch(GCD), обеспечивают более современную и эффективную инфраструктуру для реализации параллелизма, OS X и iOS также предоставляют интерфейсы для создания потоков и управления ими.*

Главным потоком называется поток, в котором стартует приложение. Обработка событий связанных со взаимодействием с UI происходит на главном потоке (такой операцией может быть обработка тапа по экрану, нажатия на клавишу клавиатуры, движение мыши и т.д.). Помимо этого, любая операция, написанная нами, будь то выполнения алгоритма, запрос в сеть или обращение к базе данных так же будет выполняться на главном потоке, что может негативно сказываться на оотклике UI. Здесь к нам на помощь приходит многопоточность - возможность выполнять операции параллельно (одновременно) на разных потоках.

## Run Loop

Run Loop - своего рода бесконечный цикл, предназначенный для обработки и координации всех событий, поступающих к нему на вход. В первую очередь стоит отметить, что у каждого потока есть свой ассоциированный Run Loop. Run Loop для главного потока приложения (UIApplication) инициализирует и стартует автоматически, в то время как для созданных потоков запускать и конфигурировать Run Loop необходимо самостоятельно.
Run Loop главного потока отлавливает все системные события и запускает их обработку на главном потоке, будь то нажатия на клавиши клавиатуры, если это macOS, или тап по экрану iOS устройства. Также Run Loop умеет управлять своим потоком: будить для выполнения некоторой работы и переводить в спячку после ее выполнения.
По большому счету, Run Loop - это то, что отличает интерактивное мобильное приложение от обычной программы. Когда Run Loop получает сообщение о событии, он запускает обработчик, ассоциированный с этим событием на своем потоке, а после выполнения усыпляет поток до следующего события, именно таким образом приложение узнает о происходящих интерактивных событиях.
Разберемся, какие же события умеет обрабатывать Run Loop:

* Input sources - различные источники ввода(мышь, клавиатура, тачскрин и т.п), кастомные источники (необходимы для передачи сообщений между потоками), а так же вызов performSelector:onThread: (метод, необходимый для вызова события по селектору на определенном потоке)
* Timer sources - все таймеры в приложении всегда обрабатываются ранлупом

Как уже говорилось ранее, Run Loop'ом главного потока управляет приложение, в то время, как мы сами управляем Run Loop'ом созданных нами потоков, таким образом мы можем явно указать, какие источники ввода должен обрабатывать Run Loop. Рассмотрим режимы работы Run Loop:

* NSDefaultRunLoopMode - режим по умолчанию, который отслеживает все основные события

* NSConnectionReplyMode - режим для работы NSConnection (в документации написанно, что этот режим нам никогда не понадобится) 

* NSModalPanelRunLoopMode - режим, отслеживающий события в модальных окнах (используется только в macOS)

* NSEventTrackingRunLoopMode - режим, который отслеживает системные события связанные с UI (скроллинг, тап по экрану, движение мыши, нажатия на клавиатуре и т.п)

* NSRunLoopCommonModes - режим, объединяющий в себе 3 других: NSDefaultRunLoopMode, NSModalPanelRunLoopMode, NSEventTrackingRunLoopMode

В качестве примера использования режимов Run Loop может быть распространенная проблема, связанная с некорректной работой таймера:

```
Timer.scheduledTimer(timeInterval: 0.1,
    target: self,
    selector: #selector(onTimerUpdate),
    userInfo: nil,
    repeats: true)
```

Проблема данного кода заключается в том, что метод scheduledTimer создает таймер и планирует выполнение события в текущем Run Loop только для режима NSDefaultRunLoopMode (.default), в то время, как обработка UI событий (скролинг, тап по дисплею и т.п) происходит в режиме NSEventTrackingRunLoopMode (.tracking). Таким образом, когда пользователь тригерит UI события, Run Loop обрабатывает события только из режима .tracking, а наш таймер тем временем, имея более низкий приоритет, не обрабатывается. Для решения данной проблемы необходимо добавить таймер в текущий Run Loop для режима NSRunLoopCommonModes (.common), который в себя включает .tracking и .default:

```
let timer = Timer(timeInterval: 1,
    target: self, 
    selector: #selector(time), 
    userInfo: nil, 
    repeats: true)
        
RunLoop.main.add(timer, forMode: .common)

```
