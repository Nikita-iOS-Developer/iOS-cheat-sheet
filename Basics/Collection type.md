# Типы коллекций

## Изменчивость коллекция

Когда мы создаем массив, словарь или множество и присваиваем его переменной, то созданная коллекция будет изменяемой. Это означает, что мы можем изменить коллекцию после ее создания путем добавления, удаления, или изменения элементов этой коллекции. И наоборот, когда мы присвоим массив или словарь константе, то он будет неизменяемым, а его размер и содержимое не может быть изменено.

*Хорошей практикой является создание неизменяемых коллекций во всех случаях, когда коллекцию не нужно менять. Делая это, мы позволяем компилятору Swift оптимизировать производительность наших коллекция.*

## Массивы

## Множества

Множество хранит различные значения одного типа в виде коллекции в неупорядоченной форме. Мы можем использовать множества как альтернативы массиву, когда порядок для нас значения не имеет или когда нам нужно быть уверенным в том, что значения внутри коллекции не повторяются.

### Хеш значения для типа Set

Тип должен быть хешируемым для того, чтобы мог храниться в множестве, таким образом тип должен предоставлять возможность для вычисления собственного значения хеша. Тип значения хеша Int должен быть для всех объектов одинаковым, чтобы можно было провести сравнение что если a == b, то и a.hashValue == b.hashValue.
Все базовые типы Swift (Int, String, Double, Bool) являются хешируемыми типами по умолчанию и могут быть использованы в качестве типов значений множества или в качестве типов ключей словаря. Значения членов перечисления без каких-либо связанных значений так же являются хешируемыми по умолчанию.

### Итерация по множеству

Множества в Swift не имеют определенного порядка. Для того, чтобы провести итерацию по множеству в определенном порядке, нам нужно использовать метод sorted(), который возвращает нам элементы коллекции в виде отсортированного массива, по умолчанию используя оператор <.

```
for genre in favoriteGenres.sorted() {
print("\(genre)")
}
```
Мы также можем получить отсортированный массив из множества:

```
var set: Set = [1,2,3,4,5,6,7]
print(set)
// [6,5,4,3,2,1,7]

var array = set.sorted()
print(array) 
// [1,2,3,4,5,6,7]
```

### Базовые операции множеств

1. Используем метод union (:) для создания нового множества состоящего из всех значений обоих множеств.
2. Используем метод intersection(:) для создания нового множества из общих значений двух входных множеств.
3. Используем метод subtracting (:) для создания множества со значениями не принадлежащих указанному множеству из двух входных.
4. Используем метод symmetricDifference(:) для создания нового множества из значений, которые не повторяются в двух входных множествах.

```
let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]

oddDigits.union(evenDigits).sorted()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersection(evenDigits).sorted()
// []
oddDigits.subtracting(singleDigitPrimeNumbers).sorted()
// [1, 9]
oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()
// [1, 2, 9]
```

### Взаимосвязь и равенство множеств

1. Используем оператор равенства (==) для определения все ли значения двух множеств одинаковы.
2. Используем метод isSubset(of:) для определения все ли значения множества содержатся в указанном множестве.
3. Используем метод isSuperset(of:), чтобы определить содержит ли множество все значения указанного множества.
4. Используем методы isStrictSubset(of:) или isStrictSuperset(of:) для определения является ли множество подмножеством или надмножеством, но не равным указанному сету.
5. Используем метод isDisjoint(with:) для определения того, отсутствуют ли общие значения в двух множествах или нет.

```
let houseAnimals: Set = ["собака", "кошка"]
let farmAnimals: Set = ["корова", "курица", "баран", "собака", "кошка"]
let cityAnimals: Set = ["ворона", "мышь"]
let set1: Set = [1,2,3]
let set2: Set = [2,3,4,5]
houseAnimals.isSubset(of: farmAnimals)
// true
farmAnimals.isSuperset(of: houseAnimals)
// true
farmAnimals.isDisjoint(with: cityAnimals)
// true
set1.isStrictSubset(of: set2)
//true
```

## Словари

В Swift тип словаря в полной форме пишется как Dictionary<Key, Value>, где Key это тип значения который используется как ключ словаря, а Value это тип значения который словарь может хранить для этих ключей.

*Тип словаря Key должен подчиняться протоколу Hashable, как тип значения множества*

### Доступ и изменение словаря

Мы можем использовать синтаксис индексов для вывода или изменения значения связанного с определенным ключом:

```
let dictionary = [1:1, 2:2, 3:3]
dictionary[1]
//1
dictionary[1] = 11
//11
```

В качестве альтернативы индексам, можно использовать метод словаря updateValue(:forKey:), чтобы установить или обновить значение для определенного ключа. Подобно примерам с индексами вверху, метод updateValue(:forKey:) устанавливает значение для ключа если оно не существует, или обновляет значение, если этот ключ уже существует. Однако, в отличие от индексов, метод updateValue(:forKey:) возвращает старое значение после выполнения обновления. Это позволяет вам проверить состоялось ли обновление или нет.
Метод updateValue(:forKey:) возвращает опциональное значение соответствующее типу значения словаря. Например, для словаря, который хранит String значения, метод возвратит String? тип, или "опциональный String". Это опциональное значение содержит старое значение для этого ключа, если оно существовало до обновления, либо nil если значение не существовало.

```
var dictionary = [1:1, 2:2]

if dictionary.updateValue(2, forKey: 3) != nil {
    print("not nil")
} else {
    print("Nil")
}
```

*Когда мы получаем значение из словаря при помощи индекса, это значение опционально*

Мы можем удалить пару ключ-значение из словаря с помощью метода removeValue(forKey:). Этот метод удаляет пару ключ-значение если она существует и затем возвращает значение , либо возвращает nil если значения не существует:

```
var figures = [1:1, 2:2]

if let removedValue = figures.removeValue(forKey: 1) {
  print("The removed figure is \(removedValue).")
} else {
  print("The figures dictionary does not contain a value for 1.")
}
// Выведет "The removed figure is 1."
```

### Итерация по словарю

Тип словаря в Swift является неупорядоченной коллекцией. Для итерации по ключам или значениям словаря в определенной последовательности, используем метод sorted() для свойств keys или values словаря.
