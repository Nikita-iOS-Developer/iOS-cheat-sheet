# Protocols

Протоколы - это набор методов и свойств без реализаций. Протокол - это тип (как класс, структура, перечисление).
Класс, структура и перечисление, который соответствует протоколу, обязан реализовать все свойства и методы что прописаны в нем (в Swift).

Пример объявления протокола:

```
protocol SomeProtocol {
    var someProperty: Int {get set}
    func aMethod(arg1: Double, anotherArgument: String) -> SomeType
    mutating func changeIt()
    init(arg: Type)
}
```

В примере выше мы можем установить только get для SomeProperty тогда оно не обязано быть устанавливаемым. someProperty может быть как stored так и computed property, главное чтобы был установлен геттер.
Указываем mutating если метод будет менять сам объект, в таком случае нам не придется указывать это в классах, но обязательно будет в структурах и перечислениях (при автозаполнении в структуре иксКод автоматически подставит слово mutating в метод).
Так же мы можем указать в протоколах свойство и метод типа (static) и все виды инициализаторов.
Протоколы могут наследоваться от других протоколов. Каждый кто реализует протокол, который наследуется от другого протокола, должен также реализовать все свойства, методы и т.д от родительских протоколов.

Пример работы с Protocol:

```
protocol Moveable {
    mutating func move(to point: CGPoint)
}
class Car: Moveable {
    func move(to point: CGPoint) { print("car is moving") }
    func changeOil() { print("Oil has been changed") }
}
struct Shape: Moveable {
    mutating func move(to point: CGPoint) { print("Shape is moving") }
    func draw() { print("Shape has been draw") }
}

var prius: Car = Car()
var square: Shape = Shape()

var thingToMove: Moveable = prius
thingToMove.move(to: CGPoint.zero)
thingToMove = square
thingToMove.move(to: CGPoint.zero)
let thingsToMove: [Moveable] = [prius, square]
```

Мы не можем создать объект протокола Moveable так как протоколы это только описание, но мы можем объявить переменную типа Moveable и присвоить в эту переменную абсолютно любой тип, объект, который этому протоколу соответствует. Это показанно в примере выше в переменной thingToMove. 

## Протоколы как тип данных

Рассмотрим пример:

```
protocol Drive {
    var speed: Double { get }
    func drive()
}

class Person: Drive {
    private (set) var speed: Double = 50 //Сеттер будет недоступен в экземпляре класса Person
    
    func drive() {
        print("Drive!")
    }
    var name: String = "Ivan"
}

//1
var person = Person
person.speed
person,drive()
person.name

//2
var person: Drive = Person
person.speed
person.drive
person.name //Ошибка так как в протоколе Drive нет описанного свойства name
```

В примере выше под номером 1 экземпляр типа Person person полностью соответствует протоколу Drive это значит что все методы и свойства описанные в протокле Drive и в классе Ptrson будут доступны в экземпляре person.
В примере под номером 2 переменная person имеет тип данных Drive и ссылается на класс Person. Так как переменная person имеет тип данных Drive то она сможет получить доступ только к тем свойствам и методам что имеет  протокол Drive. Именно поэтому у нас будет ошибка так как свойство name описанно в типе данных Person, а присвоить Person мы смогли Drive так как Person соответствует протоколу Drive.
Так как мы можем создать переменную типа Drive, то мы можем создать и массив который содержит тип Drive, функцию которая принимает или возвращает тип Drive.

## Наследование в протоколах

Наследование в протоколах похожи на наследования в классах. Наш класс может наследоваться только от одного класса, но класс может соответствовать множеству протоколов. Принято осуществлять реализацию протоколов в расширении.
Рассмотрим пример:

```
protocol Drive {
    var speed: Double { get }
    func drive()
}
protocol Bicycle: Drive {}
protocol Car: Drive {}

class Person {
    var name: String = "Tom"
}

extension Person: Bicycle, Car {
    var speed: Double {
        50
    }
    
    func drive() {
        print("Drive!")
    }
}
```

Когда мы наследуемся в протоколах это можно воспринимать как дополнение протокола. Еще наследование в протоколах можно воспринимать как разбиение интерфейса. Привидем пример:

```
//Общее описание протокола Водить
protocol Drive {
    var speed: Double { get }
    func drive()
}
///Дополняем протокол Drive и разбиваем интерфейс (лицензия водителя в протоколе Водитель)
protocol Driver: Drive {
    var driverLicense: String { get }
}
```

В примере выше мы теперь можем подписать класс, перечисление или структуру на протокол Drive что даст нам общие характеристики, или подписаться под протокол Driver что позволит нам уже точно описать данный класс, перечисление или структуру. Этот метод наследования в протоколах дает нам гибкость.  

## Протоколы для классов

Есть некоторые моменты когда протокол должен работать только на value type или reference type. Для этого мы можем обозначить протокол что он может работать только с reference type. Чтобы обозначить что протокол может работать только с классами, нам нужно написать слов AnyObject:

```
protocol Drive: AnyObject {
    var speed: Double { get }
    func drive()
}
```
 
## is и as в протоколах

Мы можем конвертировать тип из протокола в тип класса. Рассмотрим пример:

```
protocol Drive {
    var speed: Double { get }
    func drive()
}
protocol Bicycle: Drive {}
protocol Car: Drive {}

class Person {
    var name: String = "Tom"
}

extension Person: Bicycle, Car {
    var speed: Double {
        50
    }
    
    func drive() {
        print("Drive!")
    }
}

var person: Bicycle = Person()
var person2: Person? = person as? Person
```

В примере выше мы используем ключевое слово as чтобы ковертировать в тип Person. Без as будет ошибка так как под протоколом Bicycle может быть структура.
Мы так же можем проверить соответствует ли тип какому либо протоколу с помощью ключевого слова is:

```
var person: Bicycle = Person()
person is Drive //true
```


## Расширения в протоколах

Расширения в структурах, перечислениях и классах нужны в основном для того, чтобы расширить их функциональность самих типов данных и вынести эту фанкциональность за пределы этих типов. Также можно использовать расширения для разбития кода на логические части.
Расширения в протоколах нужны для того, чтобы объявить в расширении реализацию этого метода.
Рассмотрим пример:

```
protocol Drive {
    var speed: Double { get }
    func drive()
}
protocol Bicycle: Drive {}
protocol Car: Drive {
    var driverLicense: String { get }
}

extension Car {
    var driverLicense: String {
        "No driver license"
    }
}
class Person {
    var name: String = "Tom"
}

extension Person: Car {
    var speed: Double {
        50
    }
    
    func drive() {
        print("Drive!")
    }
}
```
В примере выше наш класс Person подписан под протокол Car, при этом протокол не требует реализации свойства driverLicense в классе Person, так как мы реализовали это свойство в расширении протокола.
Когда мы объявляем расширения протокола с реализацией, это значит, что любой кто подпишется на этот протокол по умолчанию сразу же получит реализацию. Мы можем реализовывать в расширении неограниченное количество свойств и методов. Так же мы можем осуществлять реализацию в расширении родительских свойств и методов в дочернем протоколе.
Когда мы подписываем тип данных под протокол с реализованными свойствами или методами, мы без проблем можем изменить реализованные свойства и методы в структуре, перечислении или классе:

```
protocol Drive {
    var speed: Double { get }
    func drive()
}
protocol Bicycle: Drive {}
protocol Car: Drive {
    var driverLicense: String { get }
}

extension Car {
    var driverLicense: String {
        "No driver license"
    }
}
class Person {
    var name: String = "Tom"
}

extension Person: Car {
    var driverLicense: String {
        "Has license"
    }
    var speed: Double {
        50
    }
    
    func drive() {
        print("Drive!")
    }
}
```

## Diamond problem

Проблема Diamond (ромбовидной) иерархии возникает, когда у нас есть иерархия протоколов, где один класс подписан от двух разных протоколов, которые в свою очередь наследуются от общего родителя и у этих протоколов есть реализация их свойств и методов. Это может привести к неоднозначности при вызове методов или доступе к свойствам.
Рассмотрим пример:

```
protocol Bicycle {
    var wheels: Int { get }
}

protocol Car {
    var wheels: Int { get }
}
extension Bicycle {
    var wheels: Int { 2 }
}

extension Car {
    var wheels: Int { 4 }
}

class Transport {}

extension Transport: Car, Bicycle {
    //Ошибка! Тип Transport не соответствует протоколам! 
}
```

В примере выше у нас оба протокола имеют реализацию и когда мы подписали наш класс на эти два протокола то Swift не знает какое свойство wheels ему реализовать в классе. Для того чтобы решить эту проблему, нужно просто переопределить в классе свойство wheels:

```
extension Transport: Car, Bicycle {
    var wheels: Int { 4 }
}
```

## Стандартные протоколы

Рассмотрим список самых популярных протоколов которые помогут нам в разработке:

1. Equatable - протокол для сравнения значений типов.
2. Comparable - протокол для сравнения и упорядочивания значения типа.
3. Codable - протокол для сериализации и десериализации данных.
4. Hashable - протокол для хэширования данных.
5. Collection - протокол для представления коллекций, таких как массивы и словари.
6. Sequence - протокол для представления последовательностей элементов.
7. IteratorProtocol - протокол для представления итераторов; используемых для обхода коллекций и последовательностей.
8. Error - протокол для представления ошибок.
9. CaseIterable - протокол позволяет получить массив всех кейсов перечисления.
10. Identifiable - протокол предоставляет удобный способ для идентификации элементов в коллекциях

### Equatable

Протокол Equatable определяет способ сравнения двух значений на равенство. Протокол Equatable имеет всего одно требование - наличие метода ==, который принимает два аргумента одного типа и возвращает булево значение (true, если два значения равны, и false в противном случае).
Вот как выглядит определение протокола Equatable в Swift:

```
protocol Equatable {
    static func ==(lhs: Self, rhs: Self) -> Bool
}
```

Чтобы наш тип данных соответствовал протоколу Equatable, нам нужно реализовать метод == для этого типа. Например, давайте создадим структуру Person, которая будет представлять человека с именем и возрастом, и сделаем ее соответствующей протоколу Equatable:

```
struct Person: Equatable {
    var name: String
    var age: Int
    
    static func ==(lhs: Person, rhs: Person) -> Bool {
        return lhs.name == rhs.name && lhs.age == rhs.age
    }
}

let person1 = Person(name: "Alice", age: 30)
let person2 = Person(name: "Bob", age: 25)

if person1 == person2 {
    print("Persons are equal")
} else {
    print("Persons are not equal")
}
```


В данном примере мы определили структуру Person и реализовали метод ==, который сравнивает два объекта типа Person по их имени и возрасту. Затем мы создали два объекта типа Person и сравнили их с помощью оператора ==.
Протокол Equatable также используется во встроенных типах данных Swift, таких как String, Int, Double и других, что позволяет нам использовать операторы сравнения (например, ==, !=) для этих типов без дополнительных усилий.

### Comparable

Протокол Comparable определяет способ сравнения двух значений для упорядочивания. Протокол Comparable имеет три требования - наличие методов <, <=, >, >=, которые принимают два аргумента одного типа и возвращают булево значение (true, если первое значение меньше, меньше или равно, больше или равно, больше соответственно).
Вот как выглядит определение протокола Comparable в Swift:

```
protocol Comparable: Equatable {
    static func <(lhs: Self, rhs: Self) -> Bool
    static func <=(lhs: Self, rhs: Self) -> Bool
    static func >=(lhs: Self, rhs: Self) -> Bool
    static func >(lhs: Self, rhs: Self) -> Bool
}
```


Чтобы наш тип данных соответствовал протоколу Comparable, нам нужно реализовать методы <, <=, >, >= для этого типа. Например, давайте создадим структуру Point, которая будет представлять точку на плоскости с координатами x и y, и сделаем ее соответствующей протоколу Comparable:

```
struct Point: Comparable {
    var x: Int
    var y: Int
    
    static func <(lhs: Point, rhs: Point) -> Bool {
        return lhs.x < rhs.x && lhs.y < rhs.y
    }
    
    static func <=(lhs: Point, rhs: Point) -> Bool {
        return lhs.x <= rhs.x && lhs.y <= rhs.y
    }
    
    static func >=(lhs: Point, rhs: Point) -> Bool {
        return lhs.x >= rhs.x && lhs.y >= rhs.y
    }
    
    static func >(lhs: Point, rhs: Point) -> Bool {
        return lhs.x > rhs.x && lhs.y > rhs.y
    }
}

let point1 = Point(x: 1, y: 2)
let point2 = Point(x: 3, y: 4)

if point1 < point2 {
    print("point1 is less than point2")
} else {
    print("point1 is not less than point2")
}
```

В данном примере мы определили структуру Point и реализовали методы <, <=, >, >=, которые сравнивают две точки по их координатам x и y. Затем мы создали две точки и сравнили их с помощью операторов сравнения.
Протокол Comparable также используется во встроенных типах данных Swift, таких как String, Int, Double и других, что позволяет нам использовать операторы сравнения для этих типов без дополнительных усилий.

### Codable

Протокол Codable в Swift предоставляет возможность сериализовать (кодировать) и десериализовать (декодировать) данные из и в различные форматы, такие как JSON, Plist, XML и другие. 
Протокол Codable объединяет два других протокола - Encodable и Decodable.
Пример использования протокола Codable:

```
struct Person: Codable {
    var name: String
    var age: Int
}

let person = Person(name: "Alice", age: 30)

// Кодирование данных в JSON
let encoder = JSONEncoder()
if let jsonData = try? encoder.encode(person) {
    if let jsonString = String(data: jsonData, encoding: .utf8) {
        print(jsonString)
    }
}

// Декодирование данных из JSON
let json = """
{
    "name": "Bob",
    "age": 25
}
"""

if let jsonData = json.data(using: .utf8) {
    let decoder = JSONDecoder()
    if let decodedPerson = try? decoder.decode(Person.self, from: jsonData) {
        print(decodedPerson)
    }
}
```

Протокол Codable значительно упрощает работу с сериализацией и десериализацией данных в Swift, позволяя легко конвертировать объекты в различные форматы и обратно.

### Hashable

Протокол Hashable в Swift является протоколом, который позволяет типу быть хешируемым. Это означает, что объекты этого типа могут быть использованы в качестве ключей в словарях (Dictionary) или могут быть добавлены в множества (Set).
Протокол Hashable требует реализации свойства hashValue, которое возвращает значение типа Int, представляющее хеш-код объекта. В Swift 4.2 и выше, вместо явного реализации свойства hashValue, можно использовать метод hash(into:) для вычисления хеш-кода.
Пример протокола Hashable:

```
struct Point: Hashable {
    var x: Int
    var y: Int
}

let point1 = Point(x: 10, y: 20)
let point2 = Point(x: 10, y: 20)

print(point1.hashValue) // Выведет: одинаковый хэш с point2
print(point2.hashValue) // Выведет: одинаковый хэш с point1

let set: Set<Point> = [point1, point2]
print(set.count) // Выведет: 1, так как point1 и point2 считаются одинаковыми
```

Важно отметить, что при реализации протокола Hashable необходимо убедиться, что объекты с одинаковыми значениями свойств имеют одинаковый хеш-код. В противном случае могут возникнуть проблемы при использовании объектов в структурах данных, зависящих от хеш-кода.
Протокол Hashable полезен для работы с коллекциями данных, где требуется быстрый доступ к элементам по ключу или исключение дубликатов.

## Collection

Протокол Collection представляет собой один из основных протоколов, который описывает коллекции значений, представленных в виде упорядоченной последовательности. Коллекции, соответствующие протоколу Collection, могут быть итерируемыми и поддерживать доступ к элементам по индексу.
Вот некоторые ключевые характеристики протокола Collection:

1. **Итерирование**: Коллекции, соответствующие протоколу Collection, могут быть перебираемыми с помощью цикла for-in.

2. **Индексированный доступ**: Коллекции, соответствующие протоколу Collection, предоставляют доступ к элементам по индексу. Это означает, что вы можете получить элемент коллекции по его индексу.

3. **Длина коллекции**: Протокол Collection определяет свойство count, которое возвращает количество элементов в коллекции.

4. **Интервалы**: Протокол Collection также определяет тип Index, который используется для представления позиции элемента в коллекции, а также методы для работы с диапазонами элементов.

Примеры стандартных типов, которые соответствуют протоколу Collection, включают массивы (Array), наборы (Set), строки (String), словари (Dictionary) и другие.
Важно отметить, что протокол Collection наследует от протокола Sequence, что означает, что все коллекции также являются последовательностями и могут использоваться везде, где ожидается последовательность.
Использование протокола Collection позволяет писать более универсальный код, который будет работать с различными типами коллекций без изменений.

### Sequence

Протокол Sequence в Swift представляет собой тип, который предоставляет последовательность значений, которые могут быть перечислены с использованием цикла for-in. Протокол Sequence определяет метод makeIterator(), который возвращает итератор для последовательности, позволяя перечислить элементы последовательности один за другим.
Пример кода, демонстрирующий использование протокола Sequence:

```
// Создаем структуру, представляющую последовательность чисел
struct CountingSequence: Sequence {
    let start: Int
    let end: Int
    
    func makeIterator() -> CountingIterator {
        return CountingIterator(start: start, end: end)
    }
}

// Создаем итератор для последовательности чисел
struct CountingIterator: IteratorProtocol {
    var current: Int
    let end: Int
    
    init(start: Int, end: Int) {
        self.current = start
        self.end = end
    }
    
    mutating func next() -> Int? {
        guard current < end else { return nil }
        defer { current += 1 }
        return current
    }
}

// Используем последовательность чисел и перечисляем их
let countingSequence = CountingSequence(start: 1, end: 5)
for number in countingSequence {
    print(number)
}
```

В этом примере мы создаем структуру CountingSequence, которая соответствует протоколу Sequence и представляет последовательность чисел от start до end. Мы также создаем структуру CountingIterator, которая соответствует протоколу IteratorProtocol и реализует метод next() для итерации по элементам последовательности. Затем мы создаем экземпляр CountingSequence и используем цикл for-in для перечисления чисел в этой последовательности.

### IteratorProtocol

Протокол IteratorProtocol представляет собой протокол, который определяет метод next(), который возвращает следующий элемент последовательности или nil, если достигнут конец последовательности. Протокол IteratorProtocol является частью итерационного интерфейса в Swift, который позволяет создавать пользовательские итераторы для перечисления элементов последовательностей.
Пример простого итератора, соответствующего протоколу IteratorProtocol:

```
struct SimpleIterator: IteratorProtocol {
    var count = 0
    let maxCount = 5
    
    mutating func next() -> Int? {
        guard count < maxCount else { return nil }
        defer { count += 1 }
        return count
    }
}

var iterator = SimpleIterator()

while let element = iterator.next() {
    print(element)
}
```

В этом примере мы создаем структуру SimpleIterator, которая соответствует протоколу IteratorProtocol. В этой структуре мы определяем переменные count и maxCount, а также реализуем метод next(), который возвращает следующий элемент последовательности или nil, если достигнут конец последовательности. Затем мы создаем экземпляр итератора и используем цикл while let для перечисления элементов, пока итератор возвращает значения.
Итераторы и протокол IteratorProtocol широко используются в Swift для работы с различными типами данных и структурами данных, позволяя эффективно перечислять элементы последовательностей.

### Error

Протокол Error является встроенным протоколом, который определяет типы, которые могут представлять ошибки или исключения в приложении. Этот протокол не содержит никаких требований, поэтому любой тип данных может быть сделан соответствующим протоколу Error, просто объявив, что он соответствует этому протоколу.
Протокол Error часто используется в Swift для определения пользовательских ошибок или исключений, которые могут возникнуть в процессе выполнения программы. Пользовательские типы данных, соответствующие протоколу Error, могут быть брошены (thrown) и обработаны с помощью конструкции do-catch или переданы через цепочку вызовов функций.
Пример пользовательской ошибки, соответствующей протоколу Error:

```
enum CustomError: Error {
    case fileNotFound
    case invalidData
}

func processFile() throws {
    // some code that may throw CustomError
    throw CustomError.fileNotFound
}

do {
    try processFile()
} catch CustomError.fileNotFound {
    print("File not found error occurred")
} catch {
    print("An error occurred: \(error)")
}
```

В этом примере мы создаем перечисление CustomError, которое соответствует протоколу Error и определяет два возможных случая ошибок. Затем у нас есть функция processFile(), которая может выбросить ошибку типа CustomError. Мы используем конструкцию do-catch, чтобы перехватить и обработать ошибку, выброшенную внутри функции.
Протокол Error играет важную роль в обработке ошибок и исключений в Swift, позволяя разработчикам создавать иерархию пользовательских ошибок и элегантно обрабатывать их в приложениях.

### CaseIterable

Протокол CaseIterable - это протокол, который позволяет создавать коллекции всех значений перечисления (enum) в виде массива. Этот протокол добавляет свойство allCases, которое представляет собой массив, содержащий все возможные значения перечисления.
Протокол CaseIterable особенно полезен, когда нам нужно перебрать все значения перечисления или выполнить операции с каждым значением без явного указания всех случаев. Вместо того, чтобы жестко кодировать все возможные значения перечисления вручную, мы можем просто сделать наше перечисление соответствующим протоколу CaseIterable.
Пример использования протокола CaseIterable:

```
enum Direction: CaseIterable {
    case north
    case south
    case east
    case west
}

let allDirections = Direction.allCases

for direction in allDirections {
    print(direction)
}
```

В этом примере мы создаем перечисление Direction, которое соответствует протоколу CaseIterable. После этого мы можем получить доступ ко всем значениям перечисления с помощью свойства allCases. Мы используем цикл for-in, чтобы перебрать все значения и напечатать их.
Протокол CaseIterable упрощает работу с перечислениями, делая доступ к всем значениям более удобным и эффективным. Он позволяет избежать повторения кода и делает наш код более легким для поддержки и расширения.

### Identifiable

Протокол Identifiable - это протокол, который определяет объект как идентифицируемый, то есть объект, который имеет уникальный идентификатор. Этот протокол требует реализации свойства id, которое должно возвращать уникальное значение для каждого объекта. Этот протокол явно показывает, что наш тип данных обладает уникальным идентификатором, что делает наш код более понятным для других разработчиков и для нас самих.
Протокол Identifiable особенно полезен при работе с коллекциями данных, когда мы хотим иметь возможность быстро идентифицировать конкретные элементы. Например, при использовании SwiftUI для отображения списка элементов в виде списка, каждый элемент должен быть идентифицируемым, чтобы правильно обновлять представление при изменении данных.
Пример использования протокола Identifiable:

```
struct User: Identifiable {
    var id: Int
    var name: String
}

let users = [
    User(id: 1, name: "Alice"),
    User(id: 2, name: "Bob"),
    User(id: 3, name: "Charlie")
]

for user in users {
    print("User \(user.name) has ID \(user.id)")
}
```

В этом примере мы создаем структуру User, которая соответствует протоколу Identifiable, поскольку у нас есть свойство id. Затем мы создаем массив пользователей и перебираем его, чтобы напечатать имя пользователя и его уникальный идентификатор.
Протокол Identifiable помогает упростить работу с данными, требующими уникальной идентификации, и делает код более понятным и поддерживаемым. Он также интегрируется хорошо с различными фреймворками и библиотеками в Swift, такими как SwiftUI.
