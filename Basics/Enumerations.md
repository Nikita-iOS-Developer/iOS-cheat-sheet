# Enumerations

Перечисление - это тип данных, который определяет набор констант, значения которых являются альтернативами друг другу.

## Синтаксис перечисления

Перечисления начинаются с ключевого слова enum, после которого идет имя перечисления и полное его определение в фигурных скобках:

```
enum SomeEnumeration {
    //здесь будет объявление перечисления
}
```

Ниже пример с четырьмя сторонами света:

```
enum CompassPoint {
    case north
    case south
    case east
    case west
}
```

*Кейсы должны быть уникальными. По умолчанию, если не задать ни какого значения для кейса, то оно соответствует названию самого кейса. При этом сами кейсы являются константами и изменять их значения нельзя*

Перечисление инициализируется одним из своих кейсов:

```
let myDirection: Direction = .east
```

## Использование перечислений с инструкцией switch

Перечисление отлично работает с условной конструкцией switch, поэтому давайте используем ее, и пройдемся по каждому нашему шагу:

```
var myDirection = Direction.east
myDirection = .north
myDirection = .south

switch myDirection {
case .north:
    print("You are heading north")
case .south:
    print("You are heading south")
case .east:
    print("You are heading east")
case .west:
    print("You are heading west")
}
```

## Итерация по кейсам перечисления

Для некоторых перечислений можно получить коллекцию всех кейсов перечисления. Нужно лишь написать: CaseIterable после имени перечисления. Swift предоставляет коллекцию всех кейсов, как свойство allCases типа перечисления. Пример:

```
 enum Beverage: CaseIterable {
    case coffee, tea, juice
}
let numberOfChoices = Beverage.allCases.count
print("\(numberOfChoices) beverages available")
// Выведет "3 beverages available"

for beverage in Beverage.allCases {
    print(beverage)
}
// coffee
// tea
// juice
```

## Исходные значения

Бывают случаи когда в коде или даже в интерфейсе необходимо использовать значение кейсов перечисления.

Как мы уже знаем, каждый кейс по умолчанию имеет значение, которое соответсвует названию кейса, но не всегда значение кейсов должны соответствовать названию. Давайте сперва посмотрим, на примере, как определить эти исходные значения:

```
enum ClothingSize: String {
    case small = "S"
    case medium = "M"
    case large = "L"
    case extraLarge = "XL"
}
```

Перед нами перечисление размеров одежды. После двоеточия мы определяем тип исходного значения: в нашем случае это тип String, далее мы можем присваивать кейсам значения этого типа. 

*Исходное значение должно быть уникальным, то есть мы не сможем два раза присвоить значение "S" или любое другое*

И теперь мы можем брать значение этих кейсов и использовать их там где они нам понадобятся

Для того что бы получить доступ к исходным значением кейсов перечисления, нам нужно обратиться к свойству rawValue этого кейса.

Давайте мы сейчас создадим переменную size, выведем на консоль исходное значение и присвоим к константе типа String:

```
var size = ClothingSize.small
print(size.rawValue)
let someString: String = size.rawValue
```

Если нам для некоторых кейсов не нужно значение, то мы можем задать их не для всех.

### Инициализация через исходное значение

Если мы объявили перечисление вместе с типом исходного значения, то перечисление автоматически получает инициализатор, который берет значение типа исходного значения (как параметр rawValue) и возвращает либо член перечисления либо nil. Мы можем использовать этот инициализатор, чтобы попытаться создать новый экземпляр перечисления.

Рассмотрим примеры:

```
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
}
let possiblePlanet = Planet(rawValue: 7)
// possiblePlanet имеет тип Planet? и его значение равно Planet.uranus
```

Конечно не все возможные значения Int найдут отклик в данном перечислении. Из-за этого инициализаторы исходных значений всегда возвращают опциональный член перечисления. В этом примере possiblePlanet типа Planet? или “опциональный Planet”.

*Инициализатор исходного значения - проваливающийся инициализатор, потому как не каждое исходное значение будет возвращать кейс перечисления*

Если мы попытаемся найти планету с номером позиции 11, то значение опциональной Planet, возвращенное исходным значением инициализатора, будет nil:

```
let positionToFind = 11
if let somePlanet = Planet(rawValue: positionToFind) {
    switch somePlanet {
    case .earth:
        print("Mostly harmless")
    default:
        print("Not a safe place for humans")
    }
} else {
    print("There isn't a planet at position \(positionToFind)")
}
// Выведет "There isn't a planet at position 11"
```

Этот пример использует привязку опционалов для попытки добраться до Planet с исходным значением 11. Выражение if let somePlanet = Planet(rawValue: 11) создает опциональную Planet и устанавливает значение somePlanet опциональной Planet, если она может быть восстановлена. В этом случае невозможно добраться до планеты с позицией 11, таким образом срабатывает ветка else.

## Ассоциативные параметры

Ассоциативные параметры или по другому связанные значения перечисления – это дополнительные значения, которые можно связать с каждым из кейсов перечисления. Они объявляются в скобках после имени каждого члена перечисления. 

Например:

```
enum TransportType {
    case car(make: String, model: String)
    case bike(brand: String)
    case walking
}

let car = TransportType.car(make: "Tesla", model: "Model S")
let bike = TransportType.bike(brand: "Specialized")
let walking = TransportType.walking
```

*Так же как и в кортежах, параметры можно не называть, но в таком случае будет сложно разобраться, какой параметр за что отвечает*

Теперь мы можем добраться до ассоциативных параметров:

```
switch car {
case .car(let make, let model):
    print("Make: \(make), Model: \(model)")
case .bike(let brand):
    print("Brand: \(brand)")
case .walking:
    print("Walking")
}
```

Если все связанные значения для кейсов перечисления извлекаются как константы или переменные, то для краткости мы можем разместить одиночное let или var перед именем кейса:

```
switch car {
case let .car(make, model):
    print("Make: \(make), Model: \(model)")
case let .bike(brand):
    print("Brand: \(brand)")
case .walking:
    print("Walking")
}
```

*Ассоциативные параметры, не работают с исходными значениями*
