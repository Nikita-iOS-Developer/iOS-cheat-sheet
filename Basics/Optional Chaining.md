# Опциональная последовательность

Опциональная цепочка (optional chaining) - процесс запросов и вызовов свойств, методов, сабскриптов (индексов) у опционала, который может быть nil. Если опционал содержит какое-либо значение, то вызов свойства, метода или сабскрипта успешен, и наоборот, если опционал равен nil, то вызов свойства, метода или сабскрипта возвращает nil. Множественные запросы могут быть соединены вместе, и вся цепочка этих запросов не срабатывает, если хотя бы один запрос равен nil.

## ОП как альтернатива принудительному извлечению

Мы обозначаем опциональную последовательность, когда ставим вопросительный знак (?) опционального значения, свойство, метод или индекс которого мы хотим вызвать, если опционал не nil. Это очень похоже на установку восклицательного знака (!) после опционального значения для принудительного извлечения его значения. Основное отличие в том, что опциональная последовательность не исполняется, если опционал равен nil, в то время как принудительное извлечение приводит к runtime ошибке, когда опционал равен nil.
Рассмотрим как отличаются опциональная последовательность от принудительного извлечения, и как она позволяет нам проверить значение на успех.
Первые два класса Person, Residence определены как:

```
class Person {
    var residence: Residence?
}
 
class Residence {
    var numberOfRooms = 1
}
```

Экземпляры Residence имеют единственное свойство numberOfRooms типа Int, со значением по умолчанию 1. Экземпляры Person имеют опциональное свойство residence типа Residence?.
Если мы создаем новый экземпляр Person, то его свойство residence по умолчанию имеет значение nil, в силу того, что оно является опционалом. В коде ниже john имеет свойство residence, значение которого nil:

```
let john = Person()
```

Если мы попытаемся получить доступ к свойству numberOfRooms свойства residence экземпляра Person, поставив восклицательный знак после residence, для принудительного извлечения, то мы получим ошибку исполнения, потому что residence не имеет значения для извлечения:

```
let roomCount = john.residence!.numberOfRooms
// ошибка runtime
```

Код, представленный выше, срабатывает успешно, если john.residence имеет не nil значение и устанавливает корректное значение типа Int для roomCount. Однако этот код всегда будет выдавать ошибку исполнения, когда residence равен nil, что указано выше.
Опциональная последовательность предоставляет альтернативный способ получить доступ к значению numberOfRooms. Для использования опциональной последовательности используем вопросительный знак, на месте восклицательного знака:

```
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// Выведет "Unable to retrieve the number of rooms."
```

## Определение классовых моделей для ОП

Мы можем использовать опциональную последовательность для вызовов свойств, методов, сабскриптов, которые находятся более чем на один уровень глубже. Это позволяет нам пробираться через подсвойства, внутри сложных моделей вложенных типов, и проверять возможность доступа свойств, методов и сабскриптов этих подсвойств.
Фрагмент кода ниже определяет четыре модели классов для использования в нескольких следующих примерах, включая примеры с многоуровневой опциональной последовательностью. Эти классы расширяют модели Person, Residence приведенные ранее, добавляя классы Room, Address со свойствами, методами и сабскриптами.
Класс Person объявляется так же как и раньше:

```
class Person {
    var residence: Residence?
}
```

Класс Residence стал намного сложнее, чем был раньше. В этот раз класс Residence определяет переменное свойство rooms, которое инициализировано пустым массивом [Room]:

```
class Residence {
    var rooms = [Room]()
    var numberOfRooms: Int {
        return rooms.count
    }
    subscript(i: Int) -> Room {
        get {
            return rooms[i]
        }
        set {
            rooms[i] = newValue
        }
    }
    func printNumberOfRooms() {
        print("Общее количество комнат равно \(numberOfRooms)")
    }
    var address: Address?
}
```

Из-за того, что эта версия Residence хранит массив экземпляров Room, его свойство numberOfRooms реализовано как вычисляемое, а не как хранимое свойство. Вычисляемое свойство numberOfRooms просто возвращает значение свойства.
В качестве сокращенного варианта доступа к массиву rooms, эта версия класса Residence предлагает сабскрипт (доступный как для чтения, так и для записи), который предоставляет доступ к комнате под требуемым индексом в массиве rooms.
Эта версия Residence так же обеспечивает метод printNumberOfRooms, который просто выводит на экран количество комнат в резиденции.
И наконец, Residence определяет опциональное свойство address типа Address?. Тип класса Address для этого свойства определен ниже.
Класс Room используется для массива rooms, в качестве простого класса с одним свойством name и инициализатором, в котором устанавливается значение свойства name как подходящее имя комнаты:

```
class Room {
    let name: String
    init(name: String) { 
        self.name = name 
    }
}
```

Последний класс в этой модели Address. Этот класс имеет три опциональных свойства типа String?. Первые два свойства buildingName, buildingNumber являются альтернативным вариантом определения конкретного здания как части адреса. Третье свойство street используется для названия улицы, для этого адреса:

```
class Address {
    var buildingName: String?
    var buildingNumber: String?
    var street: String?
    func buildingIdentifier() -> String? {
        if let buildingNumber = buildingNumber, let street = street {
            return "\(buildingNumber) \(street)"
        } else if buildingName != nil {
            return buildingName
        } else {
            return nil
        }
    }
}
```

Класс Address так же предоставляет метод buildingIdentifier(), который возвращает String?. Этот метод проверяет значения свойств экземпляра класса Address и возвращает buildingName или buildingNumber совмещенный со street если в обеих переменных содержится значение, или возвращает nil, если ни у одного из свойств значения нет.

## Доступ к свойствам через ОП

Мы можем опциональную последовательность для доступа к свойству опционального значения и проверить результат доступа к этому свойству на успешность.
Используем классы, определенные ранее, для создания нового экземпляра Person и попробуем получить доступ к свойству numberOfRooms, как мы делали ранее:

```
class Room {
    let name: String
    init(name: String) { 
        self.name = name 
    }
}

class Residence {
    var rooms = [Room]()
    var numberOfRooms: Int {
        return rooms.count
    }
    subscript(i: Int) -> Room {
        get {
            return rooms[i]
        }
        set {
            rooms[i] = newValue
        }
    }
    func printNumberOfRooms() {
        print("Общее количество комнат равно \(numberOfRooms)")
    }
    var address: Address?
}

class Address {
    var buildingName: String?
    var buildingNumber: String?
    var street: String?
    func buildingIdentifier() -> String? {
        if let buildingNumber = buildingNumber, let street = street {
            return "\(buildingNumber) \(street)"
        } else if buildingName != nil {
            return buildingName
        } else {
            return nil
        }
    }
}

class Person {
    var residence: Residence?
}

let john = Person()
if let roomCount = john.residence?.numberOfRooms {
    print("John's residence has \(roomCount) room(s).")
} else {
    print("Unable to retrieve the number of rooms.")
}
// Выведет "Unable to retrieve the number of rooms."
```

Так как john.residence равен nil, этот вызов опциональной последовательности не будет успешен как и ранее.
Мы можем попробовать установить значение свойства через опциональную последовательность:

```
let someAddress = Address()
someAddress.buildingNumber = "29"
someAddress.street = "Acacia Road"
john.residence?.address = someAddress
```

В этом примере попытка установить значение свойству address опциональному свойству residence? провалится, так как john.residence все еще nil.
Присваивание является частью опциональной цепочки, что означает, что никакой код с правой стороны не вычисляется. В предыдущем примере не так просто заметить, что someAddress никогда не вычисляется, потому что доступ к самой константе не имеет никаких побочных эффектов. Пример ниже делает тоже самое присваивание, но он использует функцию для того, чтобы создать адрес. Функция выводит "Function was called" до того, как вернется значение, что позволяет нам увидеть была ли вычислена правая часть от оператора присваивания.

```
func createAddress() -> Address {
    print("Function was called.")
    
    let someAddress = Address()
    someAddress.buildingNumber = "29"
    someAddress.street = "Acacia Road"
    
    return someAddress
}
john.residence?.address = createAddress()
```

Можно заметить, что функция createAddress() не вызывается, так как ничего в консоли у нас не выводится.

## Вызов методов через ОП

Мы можем использовать методы в опциональной последовательности чтобы проверить успешна ли прошла опциональная последовательность. Мы можем сделать это, даже если этот метод не возвращает значения
Метод printNumberOfRooms класса Residence выводит текущее значение numberOfRooms. Вот как выглядит этот метод:

```
func printNumberOfRooms() {
    print("Общее количество комнат равно \(numberOfRooms)")
}
```

Этот метод не определяет возвращаемого значения. Однако функции и методы без возвращаемого значения имеют неявный возвращаемый тип Void. Это означает, что они возвращают значение () или просто пустой кортеж.
Если мы вызовим этот метод на опциональном значении в опциональной последовательности, то он вернет тип не Void, а Void?, потому что возвращаемые значения всегда опционального типа, когда они вызываются через опциональную последовательность. Это позволяет нам использовать конструкцию if для проверки на возможность вызова метода printNumberOfRooms, даже если метод сам не определяет возвращаемого значения. Сравним возвращаемое значение от вызова printNumberOfRooms и nil, для того чтобы увидеть, что вызов метода прошел успешно:

```
if john.residence?.printNumberOfRooms() != nil {
    print("Есть возможность вывести общее количество комнат.")
} else {
    print("Нет возможности вывести общее количество комнат.")
}
// Выведет "Нет возможности вывести общее количество комнат."
```

То же самое верно, если мы попытаемся установить свойство через опциональную последовательность. Пример ниже в “Доступ к свойствам через опциональную последовательность” пытается установить значение address в john.residence, хотя свойство residence равно nil. Любая попытка установить свойство через опциональную последовательность возвращает значение Void?, которое позволяет нам сравнивать его с nil, для того, чтобы увидеть логический результат установки значения свойству (успех, провал):

```
if (john.residence?.address = someAddress) != nil {
    print("Была возможность установить адрес.")
} else {
    print("Не было возможности установить адрес.")
}
// Выведет "Не было возможности установить адрес."
```

## Доступ к сабскриптам через ОП

Мы можем  использовать опциональную последовательность для того, чтобы попробовать получить и установить значения из индекса опционального значения, и проверить успешность выполнения вызова сабскрипта.

*Когда мы получаем доступ к опциональному значению через опциональную последовательность, мы размещаем вопросительный знак до скобок сабскрипта (индекса), а не после.*

Пример ниже пробует получить значение имени первой комнаты в массиве rooms свойства john.residence, используя сабскрипт, определенный в классе Residence. Из-за того, что john.residence является nil, то вызов сабскрипта проваливается:

```
if let firstRoomName = john.residence?[0].name {
    print("Название первой комнаты \(firstRoomName).")
} else {
    print("Никак не получить название первой комнаты.")
}
// Выведет "Никак не получить название первой комнаты."
```

Вызов вопросительного знака опциональной последовательности в этом сабскрипте идет сразу после john.residence, но до скобок сабскрипта, потому что john.residence является опциональным значением, на которое применяется опциональная последовательность.
Аналогично мы можем попробовать установить новое значение через сабскрипт с помощью опциональной последовательности:

```
john.residence?[0] = Room(name: "Bathroom")
```

Это попытка установки значения через сабскрипт так же не срабатывает, так как residence все еще nil.
Если мы создадим и присвоиµ действительное значение экземпляру Residence, при помощи одного или нескольких экземпляров Room в массиве rooms, то мы сможем использовать сабскрипт на экземпляре residence для того, чтобы получить доступ к массиву rooms через опциональную последовательность:

```
let johnsHouse = Residence()
johnsHouse.rooms.append(Room(name: "Гостиная"))
johnsHouse.rooms.append(Room(name: "Кухня"))
john.residence = johnsHouse
 
if let firstRoomName = john.residence?[0].name {
    print("Название первой комнаты \(firstRoomName).")
} else {
    print("Никак не получить название первой комнаты.")
}
// Выведет "Название первой комнаты Гостиная."
```

## Получение доступа к сабскрипту (индексу) опционального типа

Если сабскрипт возвращает значение опционального типа, например ключ словаря типа Dictionary в Swift, то мы должны поставить вопросительный знак или восклицательный знак после закрывающей скобки сабскрипта чтобы получить значение:

```
var testScores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]
testScores["Dave"]?[0] = 91
testScores["Bev"]?[0] += 1
testScores["Brian"]?[0] = 72
// массив "Dave" теперь имеет вид [91, 82, 84], массив "Bev" - [80, 94, 81]
```

Пример выше определяет словарь testScores, который содержит две пары ключ/значение, которые соединяют ключ типа String со значением типа [Int]. Пример использует опциональную последовательность для установки значения первого элемента ключа "Dave" равным 91, для увеличения первого элемента массива под ключом "Bev" на 1 и для попытки установить первое значение несуществующего массива, соответствующего ключу "Brian" равным 72. Первые два вызова завершились успешно, потому что их ключи находятся в testScores. Третий вызов завершился неудачей, так как такого ключа как "Brian" в словаре не оказалось.

## Соединение нескольких уровней ОП

Вы можете соединить несколько уровней опциональных последовательностей вместе для того, чтобы пробраться до свойств, методов, сабскриптов, которые находятся глубже в модели.
Есть несколько особенностей:

* Если тип, который мы пытаемся получить не опциональный, то он станет опциональным из-за опциональной последовательности. Т.е если мы пытаемся получить значение типа Int через опциональную последовательность, то получим Int?, и это не будет зависеть от того, сколько уровней в опциональной последовательности задействовано.
* Если тип, который мы пытаемся получить, уже опциональный, то более опциональным он уже не станет, даже по причине опциональной последовательности. Т.е если мы попытаемся получить значение типа Int? через опциональную последовательность, то мы получим Int?, что опять таки не зависит от количества уровней, которые задействованы в опциональной последовательности.

Пример ниже пробует получить доступ к свойству street свойства address свойства residence экземпляра john. Здесь задействовано два уровня опциональной последовательности для того, чтобы соединить свойства residence и address, оба из которых опционального типа:

```
let johnsHouse = Residence()
johnsHouse.rooms.append(Room(name: "Гостиная"))
johnsHouse.rooms.append(Room(name: "Кухня"))
john.residence = johnsHouse

if let johnsStreet = john.residence?.address?.street {
    print("John's street name is \(johnsStreet).")
} else {
    print("Unable to retrieve the address.")
}
// Выведет "Unable to retrieve the address."
```

Значение john.residence на данный момент содержит корректный экземпляр класса Residence. Однако значение john.residence.address равно nil. Из-за этого вызов john.residence?.address?.street проваливается.
Если мы установим фактический экземпляр класса Address как значение для john.residence.address и установим фактическое значение для свойства street, то мы можем получить доступ к значению свойства street через многоуровневую опциональную последовательность (цепочку):

```
class Room {
    let name: String
    init(name: String) { 
        self.name = name 
    }
}

class Residence {
    var rooms = [Room]()
    var numberOfRooms: Int {
        return rooms.count
    }
    subscript(i: Int) -> Room {
        get {
            return rooms[i]
        }
        set {
            rooms[i] = newValue
        }
    }
    func printNumberOfRooms() {
        print("Общее количество комнат равно \(numberOfRooms)")
    }
    var address: Address?
}

class Address {
    var buildingName: String?
    var buildingNumber: String?
    var street: String?
    func buildingIdentifier() -> String? {
        if let buildingNumber = buildingNumber, let street = street {
            return "\(buildingNumber) \(street)"
        } else if buildingName != nil {
            return buildingName
        } else {
            return nil
        }
    }
}

class Person {
    var residence: Residence?
}

let john = Person()

let johnsHouse = Residence()
johnsHouse.rooms.append(Room(name: "Гостиная"))
johnsHouse.rooms.append(Room(name: "Кухня"))
john.residence = johnsHouse

let johnsAddress = Address()
johnsAddress.buildingName = "The Larches"
johnsAddress.street = "Laurel Street"
john.residence?.address = johnsAddress
 
if let johnsStreet = john.residence?.address?.street {
    print("John's street name is \(johnsStreet).")
} else {
    print("Unable to retrieve the address.")
}
// Выведет "John's street name is Laurel Street."
```

В этом примере попытка установить свойство address свойства john.residence будет успешной, потому что значение john.residence в настоящее время содержит действующий экземпляр Address.

## Связывание методов в ОП с опциональными возвращаемыми значениями

Предыдущий пример показал, как можно получить значение свойства опционального типа через опциональную последовательность. Мы так же можем использовать опциональную последовательность для вызова метода, который возвращает значение опционального типа, а затем к этой опциональной последовательности может прикрепить и возвращаемое значение самого метода, если это нужно.
Пример ниже вызывает метод buildingIdentifier класса Address через опциональную последовательность. Этот метод возвращает значение типа String?. Как было описано ранее, что возвращаемый тип этого метода после опциональной последовательности так же будет String?:

```
if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {
    print("John's building identifier is \(buildingIdentifier).")
}
// Выведет "John's building identifier is The Larches."
```

Если мы хотим продолжить свою опциональную привязку и на возвращаемое значение метода, то разместим вопросительный знак после круглых скобок самого метода:

```
if let beginsWithThe =
    john.residence?.address?.buildingIdentifier()?.hasPrefix("The") {
    if beginsWithThe {
        print("John's building identifier begins with \"The\".")
    } else {
        print("John's building identifier does not begin with \"The\".")
    }
}
// Выведет "John's building identifier begins with "The"."
```
