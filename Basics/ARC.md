# ARC

ARC - это механизм управления памятью в Swift, который автоматически отслеживает и контролирует количество ссылок на объекты во время выполнения программы. ARC следит за количеством ссылок на каждый объект и освобождает память, когда объект больше не нужен. ARC работает только с reference type.
Рассмотреим что такое Value type и Reference type.

## Value types

Опишем две концепции Value type:
1. Это Pure Value type - когда объект создает копию
2. Ссылочный Value type - когда мы передаем ссылку, а объект остается одним и темже

В Swift Value type это не Pure Value type, в Swift это Value Semantics. Отличие Pure Value type от Semantics Value type в том что когда мы что либо передаем нам не важно каким образом это передается, для нас важно чтобы при модификации каких либо данных изменялся чтобы изменялся новый объект т.е копия.

Рассмотрим архитектуру памяти: Stack и Heap.

1. Stack memory

* Простая LIFO структура данных т.е последний пришел первый вышел из памяти
* Потоко безопасна т.е всегда на каждый поток один стек
* Операция создания или удаления элементов очень быстрая

2. Heap memory

* Более сложная структура так как участки памяти могут разбиваться на разные части и если нам нужно чтото выделить мы ищем нужный участок, мы говорим системе что тот участок мы должны зарезервировать и  использовать. Вобщем много действий. 
* При работе с кучей исползуются указатели и счетчики ссылок. Счетчик ссылок говорит о том какое количество ссылок указывает на этот объект
* Куча является общей памятью т.е она делится между потоками. Если мы используем общую память то любая модификация требует синхронизацию чтобы это было потоко безопасно. Это немного накладывает эффект на производительность

Частые заблуждения в понимании памяти:
* Ссылочные типы всегда хранятся в куче а value types в стеке
* Структуры всегда более быстрее и эффективнее чем классы
* Value types обеспечивают потоко безопасность

Разберем каждое заблуждение:

1. Для ссылочного типа это 100% правда, но для value type это частично правда в зависимости это содержимого. Value type полностью будет определяться в стеке если это базовые типы данных (Int, Double, Bool и т.д) или если это наш тип и состоит он из базовых типов.
Если мы не можем определить размер типа (протоколы, дженерики, рекурсия) - это все автоматически переносится в кучу. Также если наш Value type содержится внутри ссылочного объекта, то он также переносится в кучу.
Если в нашей структуре есть динамический объект или ссылочный то часть хранится в стеке а часть указывает в кучу.
Все стандартные типы данных динамического размера (String, Array, Dictionary, Set) это все Value types которые реализуют Value semantics т.е они не являются чистым Value type. Это связанно с двумя моментами: с тем что нам нужно динамически масштабировать размер (уменьшаться или увеличиваться) и с тем что это вопрос производительности, так как создавать копии больших объектов это не очень быстро.
Сделаем вывод что для реализации семантики у нас есть два варианта: первый - это каждый раз когда мы копируем переменную с одной на другую у нас создается копия объекта что хранится в стеке и второе - это тип который хранится в куче со скрытой реализацией счетчиков ссылок для того чтобы производительность была на высоком уровне где копирование происходит только в случае модификации объекта.
Посмотри как это работает:

```
func printAdress(of object: UnsafeRawPointer) {
    let addr = Int(bitPattern: object)
    let address = String(format: "%p", addr)
    print(address)
}

struct User {
    var name: String
}

var user = User(name: "Tom")
printAdress(of: &user) // Выведет: 0х100008250
var clone = user
printAdress(of: &user) // Выведет: 0х100008250
printAdress(of: &clone) // Выведет: 0х100008260
```

В примере выше UnsafeRawPointer дает нам указатель на адрес в памяти где хранится тип данных. В функции printAdress мы делаем преобразование типов для того, чтобы нам легче читался адрес. Без преобразования было бы 0х0000000100008250.
Далее мы создаем структуру User ис оздаем ее экземпляр. Затем мы создаем копию этой структуры и выводим адреса этих структур в консоль. Из вывода мы видим что адреса разные а это значит что создалась полностью копия и эти экземпляры хранятся в стэке.

Теперь проверим стандартный тип данных массив:

```
var array = [1,2,3,4,5]
var arrayCopy = array
printAdress(of: &array) // Выведет: 0x600002794700
printAdress(of: &arrayCopy) // Выведет: 0x600002794700
arrayCopy[0] = 10
printAdress(of: &array) // Выведет: 0x600002794700
printAdress(of: &arrayCopy) // Выведет: 0x600002794750
```

Так как массив имеет динамический размер то он выносится в кучу. В примере выше мы создаем массив, его копию и выводим адреса. Первые два вывода в консоль показывают что адреса совпадаеют так как они имеют ссылку на одну область памяти что в свою очередь говорит нам на то что объект хранится в куче. Это говорит нам о том что Pure Value Type не соблюдается. Далее как только мы внесли изменения в массив мы видим что адреса с этого момента изменились т.е это указывает нам на то что создался новый объект.

2. При работе с Value type какое содержимое там не находилось именно само содержимое определяет производительность и где находится наш объект. Если Value type хранит внутри себя объект выделенный в куче сам по себе не хранит ссылку. Следовательно если у него вложенный объект находится в куче то для этого объекта ему нужно реализовать поведение счетчиков ссылок и это накладывает дополнительное время работы.
Посмотрим пример:

```
final class TinyClass {}

final class ClassOfClasses {
    let class1 = TinyClass()
    let class2 = TinyClass()
    let class3 = TinyClass()
}

struct StructOfClasses {
    let class1 = TinyClass()
    let class2 = TinyClass()
    let class3 = TinyClass()
}

let classOfClasses = ClassOfClasses()
let ref1 = classOfClasses
let ref2 = classOfClasses
let ref3 = classOfClasses

let structOfClasses = StructOfClasses()
let copy1 = structOfClasses
let copy2 = structOfClasses
let copy3 = structOfClasses

print(CFGetRetainCount(classOfClasses)) // 4
print(CFGetRetainCount(classOfClasses.class1)) // 1
print(CFGetRetainCount(classOfClasses.class2)) // 1
print(CFGetRetainCount(classOfClasses.class3)) // 1

//print(CFGetRetainCount(classOfClasses)) // Не скомпилируется так как структура не имеет счетчика ссылок
print(CFGetRetainCount(structOfClasses.class1)) // 4
print(CFGetRetainCount(structOfClasses.class2)) // 4
print(CFGetRetainCount(structOfClasses.class3)) // 4
```

Благодаря функции CFGetRetainCount() мы можем считать текущее количество ссылок на объект. В примере выше мы видим, что когда мы создаем объект класса и копируем его в несколько других значений, то счетчик ссылок меняется для внешнего класса. Но для свойств класса ссылки являются 1.
Для структуры поведение отличается, потому что сама структура не имеет счетчиков ссылок и как только мы создаем копии, у нас создается копия в стеке и каждое свойство ссылочног типа наращивает счетчик ссылок. Такое поведение влияет на производительность. Мы можем из нашего быстрого Value type при определенных условий, при большом количестве свойств которые находятся в куче мы можем превратить его в медленный объект.
Чтобы улучшить производительность больших структур Apple рекомендует использовать Indirect Storage. Принцип такого подхода заключается в том, что мы самостоятельно реализуем подход Copy-On-Write, т.е мы имитируем поведение нашей большой структуры поведению словарей, массивов. Мы делаем обертку в котором наша большая структура находится внутри класса и соответственно хранится в куче.
Indirect Storage реализовывается через дженерики:

```
final class Ref<T> {
    var value: T
    init(value: T) { self.value = value }
}

struct Box<T> {
    private var ref: Ref<T>
    init(value: T) { ref = Ref(value: value) }
    var value: T {
        get { return ref.value }
        set {
            guard isKnownUniquelyReferenced(&ref) else {
                ref = Ref(value: newValue)
                return
            }
            ref.value = newValue
        }
    }
}

struct User { var name: String }

let user = User(name: "Alexa")
let box = Box(value: user)

var boxCopy = box

boxCopy.value.name = "Siri"
print(box.value.name) // Alexa
print(boxCopy.value.name) // Siri
```

В коде выше у нас есть класс Ref с одним полем, структура Box которая хранит ссылку на класс Ref. Для того чтобы самостоятельно реализовать Copy-On-Write мы написали в стрктуре вычисляемое свойство которое при считывании возвращает класс, а при модификации мы создаем копию если объект уже существует. Для этого мы используем глобальную системную функцию isKnownUniquelyReferenced() которая проверяет является ли счетчик ссылок единичкой. Если у нас больше одной ссылки на объект, значит нам нужно создать копию, если нет мы просто присваиваем новое значение в ту же ссылку.

*Улучшать производительность в Value type следует в фреймворках, библиотеках или в очень больших приложениях. Если приложение небольшое то проблема в скорости реализации может скрываться в других местах.*

3. Value type могут быть не потоко безопасными так как работа с многопоточностью у нас происходит в замыканиях. Как известно если замыкание принимает Value type из вне то замыкание привязывает ссылку.
Рассмотрим пример:

```
var balance = 1200
struct ATM {
    let tag: String
    func withdraw(value: Int) {
        print("\(self.tag): checking if balance contains sufficient money")
        if balance > value {
            print("\(self.tag): Balance is sufficient, please wait while processing withdrawal")
            // sleeping for some randome time, simulating a long process
            Thread.sleep(forTimeInterval: Double.random(in: 0...2))
            balance -= value
            print("\(self.tag): Done: \(value) has been withdrawn")
            print("\(self.tag): current balance is \(balance)")
        } else {
            print("\(self.tag): Can't withdraw: insufficient balance")
        }
    }
}
DispatchQueue.global().async {
    let first = ATM(tag: "firstATM"); first.withdraw(value: 1000)
}
DispatchQueue.global().async {
    let second = ATM(tag: "secondATM"); second.withdraw(value: 800)
}

// secondATM: Balance is sufficient, please wait while processing withdrawal
// firstATM: Balance is sufficient, please wait while processing withdrawal
// firstATM: Done: 1000 has been withdrawn
// firstATM: current balance is 200
// secondATM: Done: 800 has been withdrawn
// secondATM: current balance is -600
```

В примере выше в консоле мы ингода будем получать непредсказуемый результат. Мы не должны забывать про эту проблему при работе с замыканиями и Value type. При работе с многопоточностью мы должны соблюдать методы синхронизации и безопасной работы с потоками.

Рекомендации:

* Всегда по умолчанию создаем константы (все константы по умолчанию работают быстрее)
* Никогда не делаем и не рассчитываем на преждевременную оптимизацию
* Используем общую семнатику для логически связанных типов (не нужно при написании каких либо функций, классов делать так что наши логически связанный типы имеют различную семантику)
* Если мы пишем модель который должен быть высокопроизводительный и мы видим проблему производительности которую мы не можем решить, то стоит обратить внимание на большие структуры которые внутри себя хранят reference type. Используем Indirected Storage.
* Не забываем про соответствующие подходы в потоко безопасности в многопоточной среде.
* Используем вложенные типы. Они делают более структурированную программу и убирают лишний доступ к типам которые связанны с одним конкретным типом. Также мы делаем зависимую типизацию одного типа к другому.
* Используем перечисления если у нас есть ограниченный набор доступных значений. Они более безопасные в плане типа и работают намного быстрее. Стараемся делать их вложенными типами.

*Все эти маленькие оптимизации вместе помогут нам создать значительный прирост производительности.*
