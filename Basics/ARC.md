# ARC

ARC - это механизм управления памятью в Swift, который автоматически отслеживает и контролирует количество ссылок на объекты во время выполнения программы. ARC следит за количеством ссылок на каждый объект и освобождает память, когда объект больше не нужен. ARC работает только с reference type.
Каждый раз, когда мы создаем экземпляр класса, ARC выделяет кусок памяти для хранения информации об этом экземпляре. В этой памяти хранится информация о типе экземпляра со значениями любых хранимых свойств, связанных с этим экземпляром.
Кроме того, когда экземпляр больше не нужен, ARC освобождает память, используемым этим экземпляром, чтобы вместо этого использовать память для других целей. Это гарантирует, что экземпляры класса не занимают места в памяти, когда они больше не нужны.
Однако, если ARC освободит экземпляр, который все еще используется, то станет невозможно получить доступ к свойствам этого экземпляра или вызвать методы этого экземпляра. Действительно, если мы пытаемся получить доступ к экземпляру, наше приложение, скорее всего, потерпит крах.
Чтобы убедиться, что экземпляры не исчезают, пока они еще нужны, ARC отслеживает сколько свойств, констант и переменных в настоящее время ссылаются на каждый экземпляр класса. ARC не освобождает экземпляр, если по крайней мере одна активная ссылка на экземпляр все еще существует.
Чтобы сделать это возможным, всякий раз, когда мы присваиваем экземпляр класса свойству, константе или переменной, это свойство, константа или переменная делает сильную ссылку на экземпляр. Ссылка называется strong ссылкой, потому что она держится на этом экземпляре и не позволяет его освобождать до тех пор, пока эта сильная ссылка остается.
Какие бывают ссылки на объект:
* strong - пока у кого-то есть сильная ссылка на объект, этот объект будет существовать в куче. По умолчанию для всех свойств, констант и переменных.
* weak - ссылается на объект в куче, но эта ссылка не учитывается при подсчете ссылок, когда объект освобождается из памяти weak ссылка устанавливается в nil (обозначая что объект уже освободился из памяти). Соответственно weak ссылки принадлежат к типу Optional так как могут быть установлены в nil.
* unowned - ссылается на объект в куче, но эта ссылка не учитывается при подсчете ссыло, когда объект освобождается из памяти и после этого мы пытаемся использовать экземпляр по unowned ссылке, то наша программа упадет. Редко использется в основном, чтобы разрушить ссылочные циклы (memory cycles)
 Посмотрим как это все выглядит и работает в коде:
 
 ```
class Person {
    var name: String = "Tom"
    var creditCard: CreditCard?
    
    deinit {
        print("person deinit")
    }
}

var person: Person? = Person()
var person1 = person

person = nil
person1 = nil
//person deinit
 ```
 
 В примере выше мы создаем класс Person и создаем его экземпляр person. Далее мы создаем другой экземпляр person1 и копируем ему адрес person, тем самым теперь две ссылки ссылаются на один экземпляр. Эти две ссылки хранятся в стеке которые ссылаются на heap. Переменные person и person1 являются сильными ссылками (strong) и они удерживают объект в памяти. Когда мы занилили person деинит не был вызван так как удалилась только ссылка наобъект, сам объект еще находится в памяти так как ссылка person1 еще ссылается на объект. Когда мы занилили уже person1 то deinit вызвался, поскольку больше нет указателей на объект и соответственно объект удален из памяти.
 Еще есть один мемнт что ссылки удаляются автоматически когда заканчивается зона видимости:
 
 ```
 var person: Person? = Person
 
 do {
 var person1 = person
 person = nil
}
//person deinit 
 ```
 
 Пойдем дальше и попробуем понять как работают reference types:
 
 ```
class Person {
    var name: String = "Tom"
    var creditCard: CreditCard?
    
    deinit {
        print("person deinit")
    }
}

class CreditCard {
    var number: Int?
    var holder: Person?
    
    deinit {
        print("credit card deinit")
    }
}

do {
    let person: Person? = Person()
    let creditCard: CreditCard? = CreditCard()
    creditCard?.number = 44040404040404
    
    person?.creditCard = creditCard
    creditCard?.holder = person
}
 ```

В примере выше деинициализатор не сработает потому что у нас утечка памяти. В нашем случае у нас всего 4 strong ссылки: первые две это экземпляры класса person и creditDCard. Когда мы присвоили person?.creditCard = creditCard у нас теперь две сильные ссылки ссылаются на CreditCard тоже самое у нас и с Person. При выходе из зоны видимости у нас удаляютсяссылки person и creditCard но объект продолжает жить поскольку свойства внутри классов до сих пор ссылаются друг на друга. Это называется утечка памяти (reference cycle).
Чтоы решить эту проблему нам нужно пометить одно из свойств в наших классов как weak или unowned:

```
class Person {
    var name: String = "Tom"
    var creditCard: CreditCard?
    
    deinit {
        print("person deinit")
    }
}

class CreditCard {
    var number: Int?
    weak var holder: Person?
    
    deinit {
        print("credit card deinit")
    }
}

do {
    let person: Person? = Person()
    let creditCard: CreditCard? = CreditCard()
    creditCard?.number = 44040404040404
    
    person?.creditCard = creditCard
    creditCard?.holder = person
}
``` 

Так как помеченные этими словами ссылки не учитываются ARC то при потере внешней ссылки экземпляра класса со слабой ссылкой внутри этого класса (creditCard), количество ссылок на этот экземпляр станет равно 0 а значит объект будет удален из памяти. Следовательно когда экземпляр удален то на другой экземпляр (person) осталась тоже одна сильная ссылка и соответственно он так же удалится из памяти.
Посмотрим на пример weak в замыканиях:

```
class Animal {
    var name: String = "Bobik"
    
    var command: () -> Void = {}
    deinit {
        print("deinit")
    }
}

var pet = Animal()
pet.command = { print(pet.name) }
pet.command() 
```

В примере выше деинит не вызвался так как замыкание внутри себя имеет дополнительную ссылку на экземпляр класса pet. Чтобы сделать ссылку слабой мы пишем внутри замыкания в квадратных скобках слово weak и далее перечисляем что будет слабой ссылкой [weak pet].

Рассмотрим из чего состоит оперативная память:

* Сегмент кода (text)
* Сегмент данных (глобальные переменные - те переменные что не создаются в какой либо зоне видимости, BSS - глобальные переменные без инициализации, heap - может быть не один)
* Сегмент стека - стек может быть не один

При выделении памяти программа использует две основные области в оперативной памяти - стек(stack) и куча(heap). В этих областях памяти хранятся такие объекты как Value Type и Reference Type. Разберемся что это за объекты и чем стек отличается от кучи.

## Value types and Reference Types

* Value Type (Тип значения) - каждый экземпляр хранит уникальную копию своих данных. То есть происходит создание нового экземпляра (копии) при присвоении значения переменной/константе или при передаче экземпляра в функцию.

Опишем две концепции Value type:
1. Это Pure Value type - когда объект создает копию
2. Ссылочный Value type - когда мы передаем ссылку, а объект остается одним и темже

В Swift Value type это не Pure Value type, в Swift это Value Semantics. Отличие Pure Value type от Semantics Value type в том что когда мы что либо передаем нам не важно каким образом это передается, для нас важно чтобы при модификации каких либо данных изменялся чтобы изменялся новый объект т.е копия.

* Reference Type (Ссылочный тип) - каждый экземпляр использует одну копию данных. То есть сохраняется/возвращается ссылка на тот же экземпляр при присвоении значения переменной/константе или при передаче экземпляра в функцию.

Рассмотрим архитектуру памяти: Stack и Heap.

### Stack memory

* Простая LIFO структура данных т.е последний пришел первый вышел из памяти
* Потоко безопасна т.е всегда на каждый поток один стек
* Операция создания или удаления элементов очень быстрая

### Heap memory

* Более сложная структура так как участки памяти могут разбиваться на разные части и если нам нужно чтото выделить мы ищем нужный участок, мы говорим системе что тот участок мы должны зарезервировать и  использовать. Вобщем много действий. 
* При работе с кучей исползуются указатели и счетчики ссылок. Счетчик ссылок говорит о том какое количество ссылок указывает на этот объект
* Куча является общей памятью т.е она делится между потоками. Если мы используем общую память то любая модификация требует синхронизацию чтобы это было потоко безопасно. Это немного накладывает эффект на производительность

Частые заблуждения в понимании памяти:
* Ссылочные типы всегда хранятся в куче а value types в стеке
* Структуры всегда более быстрее и эффективнее чем классы
* Value types обеспечивают потоко безопасность

Разберем каждое заблуждение:

1. Для ссылочного типа это 100% правда, но для value type это частично правда в зависимости это содержимого. Value type полностью будет определяться в стеке если это базовые типы данных (Int, Double, Bool и т.д) или если это наш тип и состоит он из базовых типов.
Если мы не можем определить размер типа (протоколы, дженерики, рекурсия) - это все автоматически переносится в кучу. Также если наш Value type содержится внутри ссылочного объекта, то он также переносится в кучу.
Если в нашей структуре есть динамический объект или ссылочный то часть хранится в стеке а часть указывает в кучу.
Все стандартные типы данных динамического размера (String, Array, Dictionary, Set) это все Value types которые реализуют Value semantics т.е они не являются чистым Value type. Это связанно с двумя моментами: с тем что нам нужно динамически масштабировать размер (уменьшаться или увеличиваться) и с тем что это вопрос производительности, так как создавать копии больших объектов это не очень быстро.
Сделаем вывод что для реализации семантики у нас есть два варианта: первый - это каждый раз когда мы копируем переменную с одной на другую у нас создается копия объекта что хранится в стеке и второе - это тип который хранится в куче со скрытой реализацией счетчиков ссылок для того чтобы производительность была на высоком уровне где копирование происходит только в случае модификации объекта.
Посмотри как это работает:

```
func printAdress(of object: UnsafeRawPointer) {
    let addr = Int(bitPattern: object)
    let address = String(format: "%p", addr)
    print(address)
}

struct User {
    var name: String
}

var user = User(name: "Tom")
printAdress(of: &user) // Выведет: 0х100008250
var clone = user
printAdress(of: &user) // Выведет: 0х100008250
printAdress(of: &clone) // Выведет: 0х100008260
```

В примере выше UnsafeRawPointer дает нам указатель на адрес в памяти где хранится тип данных. В функции printAdress мы делаем преобразование типов для того, чтобы нам легче читался адрес. Без преобразования было бы 0х0000000100008250.
Далее мы создаем структуру User ис оздаем ее экземпляр. Затем мы создаем копию этой структуры и выводим адреса этих структур в консоль. Из вывода мы видим что адреса разные а это значит что создалась полностью копия и эти экземпляры хранятся в стэке.

Теперь проверим стандартный тип данных массив:

```
var array = [1,2,3,4,5]
var arrayCopy = array
printAdress(of: &array) // Выведет: 0x600002794700
printAdress(of: &arrayCopy) // Выведет: 0x600002794700
arrayCopy[0] = 10
printAdress(of: &array) // Выведет: 0x600002794700
printAdress(of: &arrayCopy) // Выведет: 0x600002794750
```

Так как массив имеет динамический размер то он выносится в кучу. В примере выше мы создаем массив, его копию и выводим адреса. Первые два вывода в консоль показывают что адреса совпадаеют так как они имеют ссылку на одну область памяти что в свою очередь говорит нам на то что объект хранится в куче. Это говорит нам о том что Pure Value Type не соблюдается. Далее как только мы внесли изменения в массив мы видим что адреса с этого момента изменились т.е это указывает нам на то что создался новый объект.

2. При работе с Value type какое содержимое там не находилось именно само содержимое определяет производительность и где находится наш объект. Если Value type хранит внутри себя объект выделенный в куче сам по себе не хранит ссылку. Следовательно если у него вложенный объект находится в куче то для этого объекта ему нужно реализовать поведение счетчиков ссылок и это накладывает дополнительное время работы.
Посмотрим пример:

```
final class TinyClass {}

final class ClassOfClasses {
    let class1 = TinyClass()
    let class2 = TinyClass()
    let class3 = TinyClass()
}

struct StructOfClasses {
    let class1 = TinyClass()
    let class2 = TinyClass()
    let class3 = TinyClass()
}

let classOfClasses = ClassOfClasses()
let ref1 = classOfClasses
let ref2 = classOfClasses
let ref3 = classOfClasses

let structOfClasses = StructOfClasses()
let copy1 = structOfClasses
let copy2 = structOfClasses
let copy3 = structOfClasses

print(CFGetRetainCount(classOfClasses)) // 4
print(CFGetRetainCount(classOfClasses.class1)) // 1
print(CFGetRetainCount(classOfClasses.class2)) // 1
print(CFGetRetainCount(classOfClasses.class3)) // 1

//print(CFGetRetainCount(classOfClasses)) // Не скомпилируется так как структура не имеет счетчика ссылок
print(CFGetRetainCount(structOfClasses.class1)) // 4
print(CFGetRetainCount(structOfClasses.class2)) // 4
print(CFGetRetainCount(structOfClasses.class3)) // 4
```

Благодаря функции CFGetRetainCount() мы можем считать текущее количество ссылок на объект. В примере выше мы видим, что когда мы создаем объект класса и копируем его в несколько других значений, то счетчик ссылок меняется для внешнего класса. Но для свойств класса ссылки являются 1.
Для структуры поведение отличается, потому что сама структура не имеет счетчиков ссылок и как только мы создаем копии, у нас создается копия в стеке и каждое свойство ссылочног типа наращивает счетчик ссылок. Такое поведение влияет на производительность. Мы можем из нашего быстрого Value type при определенных условий, при большом количестве свойств которые находятся в куче мы можем превратить его в медленный объект.
Чтобы улучшить производительность больших структур Apple рекомендует использовать Indirect Storage. Принцип такого подхода заключается в том, что мы самостоятельно реализуем подход Copy-On-Write, т.е мы имитируем поведение нашей большой структуры поведению словарей, массивов. Мы делаем обертку в котором наша большая структура находится внутри класса и соответственно хранится в куче.
Indirect Storage реализовывается через дженерики:

```
final class Ref<T> {
    var value: T
    init(value: T) { self.value = value }
}

struct Box<T> {
    private var ref: Ref<T>
    init(value: T) { ref = Ref(value: value) }
    var value: T {
        get { return ref.value }
        set {
            guard isKnownUniquelyReferenced(&ref) else {
                ref = Ref(value: newValue)
                return
            }
            ref.value = newValue
        }
    }
}

struct User { var name: String }

let user = User(name: "Alexa")
let box = Box(value: user)

var boxCopy = box

boxCopy.value.name = "Siri"
print(box.value.name) // Alexa
print(boxCopy.value.name) // Siri
```

В коде выше у нас есть класс Ref с одним полем, структура Box которая хранит ссылку на класс Ref. Для того чтобы самостоятельно реализовать Copy-On-Write мы написали в стрктуре вычисляемое свойство которое при считывании возвращает класс, а при модификации мы создаем копию если объект уже существует. Для этого мы используем глобальную системную функцию isKnownUniquelyReferenced() которая проверяет является ли счетчик ссылок единичкой. Если у нас больше одной ссылки на объект, значит нам нужно создать копию, если нет мы просто присваиваем новое значение в ту же ссылку.

*Улучшать производительность в Value type следует в фреймворках, библиотеках или в очень больших приложениях. Если приложение небольшое то проблема в скорости реализации может скрываться в других местах.*

3. Value type могут быть не потоко безопасными так как работа с многопоточностью у нас происходит в замыканиях. Как известно если замыкание принимает Value type из вне то замыкание привязывает ссылку.
Рассмотрим пример:

```
var balance = 1200
struct ATM {
    let tag: String
    func withdraw(value: Int) {
        print("\(self.tag): checking if balance contains sufficient money")
        if balance > value {
            print("\(self.tag): Balance is sufficient, please wait while processing withdrawal")
            // sleeping for some randome time, simulating a long process
            Thread.sleep(forTimeInterval: Double.random(in: 0...2))
            balance -= value
            print("\(self.tag): Done: \(value) has been withdrawn")
            print("\(self.tag): current balance is \(balance)")
        } else {
            print("\(self.tag): Can't withdraw: insufficient balance")
        }
    }
}
DispatchQueue.global().async {
    let first = ATM(tag: "firstATM"); first.withdraw(value: 1000)
}
DispatchQueue.global().async {
    let second = ATM(tag: "secondATM"); second.withdraw(value: 800)
}

// secondATM: Balance is sufficient, please wait while processing withdrawal
// firstATM: Balance is sufficient, please wait while processing withdrawal
// firstATM: Done: 1000 has been withdrawn
// firstATM: current balance is 200
// secondATM: Done: 800 has been withdrawn
// secondATM: current balance is -600
```

В примере выше в консоле мы ингода будем получать непредсказуемый результат. Мы не должны забывать про эту проблему при работе с замыканиями и Value type. При работе с многопоточностью мы должны соблюдать методы синхронизации и безопасной работы с потоками.

Рекомендации:

* Всегда по умолчанию создаем константы (все константы по умолчанию работают быстрее)
* Никогда не делаем и не рассчитываем на преждевременную оптимизацию
* Используем общую семнатику для логически связанных типов (не нужно при написании каких либо функций, классов делать так что наши логически связанный типы имеют различную семантику)
* Если мы пишем модель который должен быть высокопроизводительный и мы видим проблему производительности которую мы не можем решить, то стоит обратить внимание на большие структуры которые внутри себя хранят reference type. Используем Indirected Storage.
* Не забываем про соответствующие подходы в потоко безопасности в многопоточной среде.
* Используем вложенные типы. Они делают более структурированную программу и убирают лишний доступ к типам которые связанны с одним конкретным типом. Также мы делаем зависимую типизацию одного типа к другому.
* Используем перечисления если у нас есть ограниченный набор доступных значений. Они более безопасные в плане типа и работают намного быстрее. Стараемся делать их вложенными типами.

*Все эти маленькие оптимизации вместе помогут нам создать значительный прирост производительности.*
