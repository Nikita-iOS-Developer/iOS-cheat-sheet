# Инициализация

Инициализация - подготовительный процесс экземпляра класса, структуры или перечисления для дальнейшего использования. Этот процесс включает в себя установку начальных значений для каждого свойства хранения этого экземпляра и проведение любых настроек или инициализации, которые нужны до того, как экземпляр будет использоваться.
Экземпляры классовых типов также могут реализовывать деинициализаторы, которые проводят любую чистку прямо перед тем, как экземпляр класса будет освобожден.

## Инициализация свойств

Классы и структуры должны устанавливать начальные значения у всех свойств хранения во время создания класса или структуры. Свойства хранения не могут быть оставлены в неопределённом состоянии.
Мы можем установить начальное значение свойства внутри инициализатора или присвоить ему значение по умолчанию, как часть определения свойства.

*Во время инициализации свойств, значение устанавливается напрямую, без вызова наблюдателей*

### Инициализаторы

Инициализаторы вызываются для создания нового экземпляра конкретного типа. В самой простой своей форме инициализатор работает как метод экземпляра без параметров, написанный с помощью ключевого слова init:

```
init() {
    // инициализация проводится тут
}
```

Пример ниже определяет новую структуру Fahrenheit для хранения температур, представленных в Фаренгейтах. Структура Fahrenheit имеет всего одно свойство, temperature типа Double:

```
struct Fahrenheit {
    var temperature: Double
    init() {
        temperature = 32.0
    }
}
var f = Fahrenheit()
print("Значение температуры по умолчанию \(f.temperature)° по Фаренгейту")
// Выведет "Значение температуры по умолчанию 32.0° по Фаренгейту"
```

Структура определяет один инициализатор, init, без параметров, который инициализирует хранимую температуру равную 32.0 (температура замерзания воды по Фаренгейту).

### Дефолтные значения свойств

Мы можем установить исходное значение свойства в инициализаторе. Так же мы можем указать значение свойства по умолчанию, как часть определения свойства. Мы указываем значение свойства по умолчанию, написав исходное значение свойства, когда оно определено.

Мы можем написать структуру Fahrenheit в более простой форме, указав значение по умолчанию для свойства temperature, в месте его объявления:

```
struct Fahrenheit {
  var temperature = 32.0
}
```

## Настройка инициализации

Мы можем настроить процесс инициализации входными параметрами и опциональными типами свойств или присваиванием значений для постоянных свойств во время инициализации.

### Параметры инициализации

Мы можем показать параметры инициализации для того чтобы создать объект с необходимыми нам значениями. Параметры инициализации имеют те же возможности и синтаксис как и параметры функции или метода.
Следующий пример определяет структуру Celsius, которая хранит температуру в Цельсиях. Структура Celsius реализует два пользовательских инициализатора init(fromFahrenheit: ) и init(fromKelvin: ), которые инициализируют новый экземпляр структуры со значением другой температурной шкалы:

```
struct Celsius {
    var temperatureInCelsius: Double
    init(fromFahrenheit fahrenheit: Double) {
        temperatureInCelsius = (fahrenheit - 32.0) / 1.8
    }
    init(fromKelvin kelvin: Double) {
        temperatureInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius is 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius is 0.0
```

Первый инициализатор имеет один параметр с внешним именем fromFahrenheit и с локальным именем fahrenheit. Второй инициализатор имеет один параметр с внешним именем fromKelvin и локальным именем kelvin. Оба инициализатора конвертируют их единственный аргумент в значение по Цельсию и сохраняют это значение в свойство temperatureInCelsius.

Как и в случае с параметрами функций или методов, параметры инициализации могут иметь локальные имена для использования внутри тела инициализатора и внешние для использования при вызове инициализатора.
Однако инициализаторы не имеют своего имени до круглых скобок, как это имеют методы или функции. Поэтому имена и типы параметров инициализатора играют важную роль в определении того, какой инициализатор и где может быть использован. Из-за этого Swift предоставляет автоматические внешние имена для каждого параметра, если вы, конечно, не укажете свое внешнее имя.
Следующий пример определяет структуру Color с тремя постоянными свойствами red, green, blue. Эти свойства имеют значения от 0.0 до 1.0, для индикации количества соответствующего цвета.
Color имеет инициализатор с тремя параметрами red, green, blue типа Double(компоненты цвета красного, зеленого, синего). Также Color имеет второй инициализатор с одним параметром white, который нужен для предоставления значения для всех трех компонентов цвета.

```
struct Color {
    let red, green, blue: Double
    init(red: Double, green: Double, blue: Double) {
        self.red   = red
        self.green = green
        self.blue  = blue
    }
    init(white: Double) {
        red   = white
        green = white
        blue  = white
    }
}
```

### Опциональные типы свойств

Опциональным свойствам в классе по умолчанию присвоится значение nil, если их не установить в инициализаторе.

```
class SurveyQuestion {
    var text: String
    var response: String?
    init(text: String) {
        self.text = text
    }
    func ask() {
        print(text)
    }
}
let cheeseQuestion = SurveyQuestion(text: "Нравится ли вам сыр?")
cheeseQuestion.ask()
// Выведет "Нравится ли вам сыр?"
cheeseQuestion.response = "Да, я люблю сыр"
```


### Присваивание значений постоянным свойствам во время инициализации

Мы можем присвоить значения постоянных (когда свойство константа) свойств в любой точке вашего процесса инициализации. Как только для свойства константы присваивается значение, оно не может быть далее изменено.

*В экземплярах класса постоянное свойство может быть изменено только во время инициализации класса, в котором оно представлено. Оно не может быть изменено подклассом.*

## Дефолтные инициализаторы

Swift предоставляет дефолтный инициализатор для любой структуры или базового класса, который имеет значение по умолчанию для всех его свойств и не имеет ни одного инициализатора. Дефолтный инициализатор просто создает новый экземпляр со всеми его свойствами с уже присвоенными значениями по умолчанию.

### Почленные инициализаторы структурных типов

Структурные типы автоматически получают почленный инициализатор, если они не определяют своего пользовательского инициализатора. Это верно даже при условии, что хранимые свойства не имеют значений по умолчанию.
Почленный инициализатор - сокращенный способ инициализировать свойства члена нового экземпляра структуры. Начальные значения для свойств нового экземпляра могут быть переданы в почленный инициализатор по имени.

## Делегирование инициализатора для типов значений

Инициализаторы могут вызывать другие инициализаторы для инициализации части экземпляра. Этот процесс называется как делегирование инициализатора. Он позволяет избегать дублирования кода в разных инициализаторах. Правила того, как работает делегирование инициализатора и для каких форм делегирования это возможно, для типов значений и ссылочных типов разные.
Для типов значений мы используем self.init для ссылки на остальные инициализаторы одного и того же типа значения, когда мы пишем свои инициализаторы. Мы можем вызывать self.init из инициализатора.
Если мы определим пользовательский инициализатор для типов значений, то мы больше не будем иметь доступа к дефолтному инициализатору (или почленному инициализатору, если это структура) для этого типа. Такое ограничение предотвращает ситуацию, в которой настройка важного дополнения в более сложном инициализаторе может быть пропущена при случайном использовании автоматического инициализатора.

*Если мы хотим использовать и дефолтный и наш инициализатор в структуре, то наш инициализатор мы должны написать в расширении к этой структуре*

Следующий пример определяет пользовательскую структуру Rect для отображения геометрического прямоугольника. Примеру нужно добавить две вспомогательные структуры Size, Point, каждая из которых предоставляет значения по умолчанию 0.0 для своих свойств:

```
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0, y = 0.0
}
```

Мы можем инициализировать структуру Rect тремя способами: используя свою нулевую инициализацию значений свойств origin и size, предоставляя определенную точку и размер, или предоставляя точку центра и размер. Эти опции инициализации представлены тремя инициализаторами, которые являются частью определения структуры Rect:

```
struct Rect {
    var origin = Point()
    var size = Size()
    init() {}
    init(origin: Point, size: Size) {
        self.origin = origin
        self.size = size
    }
    init(center: Point, size: Size) {
        let originX = center.x - (size.width / 2)
        let originY = center.y - (size.height / 2)
        self.init(origin: Point(x: originX, y: originY), size: size)
    }
}
```

Первый инициализатор Rect - init() функционально тот же самый, что и дефолтный инициализатор, который бы получила структура, если бы не имела пользовательских инициализаторов. Инициализатор имеет пустое тело, отображенное парой пустых фигурных скобок {}, и не проводит никакой инициализации. Вызывая такой инициализатор, мы возвращаем экземпляр Rect, который имеет инициализированные свойства origin, size значениями Point(x: 0.0, y: 0.0) и Size(width: 0.0, height: 0.0), которые известны из определения свойств:

```
let basicRect = Rect()
//исходная точка Rect (0.0, 0.0) и его размер (0.0, 0.0)
```

Второй инициализатор Rect - init(origin:size: ) функционально то же самое что и почленный инициализатор, который могла бы иметь структура, если бы не имела пользовательских инициализаторов. Этот инициализатор просто присваивает значения аргументов origin, size соответствующим свойствам:

```
let originRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0))
//исходная точка Rect (2.0, 2.0) и его размер (5.0, 5.0)
```

Третий инициализатор Rect - init(center:size: ) немного более сложный. Он начинается с вычисления соответствующей исходной точки, основываясь на точке center и значении size. Только потом он вызывает ( или делегирует) init(origin:size: ) инициализатор, который хранит новую исходную точку и значения размеров соответствующих свойств:

```
let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))
//исходная точка centerRect’а равна (2.5, 2.5) и его размер (3.0, 3.0)
```

## Наследование и инициализация класса

Всем свойствам класса, включая и те, что унаследованы у суперкласса должны быть присвоены начальные значения, во время их инициализации.
Swift определяет два вида инициализаторов классовых типов для проверки того, что все свойства получили какие-либо значения. Они известны как назначенные инициализаторы (конструкторы) и вспомогательные инициализаторы.

### Назначенный и вспомогательный инициализатор

Назначенные инициализаторы в основном являются инициализаторами класса. Они предназначены для того, чтобы полностью инициализировать все свойства представленные классом и чтобы вызвать соответствующий инициализатор суперкласса для продолжения процесса инициализации цепочки наследований суперклассов.
Так сложилось, что классы чаще всего имеют очень мало назначенных инициализаторов, чаще всего бывает, что класс имеет всего один инициализатор. Назначенные инициализаторы объединяют в себе все точки, через которые проходит процесс инициализации и через которые процесс инициализации идет по цепочке в суперкласс.
Каждый класс должен иметь хотя бы один назначенный инициализатор. В некоторых случаях, это требование удовлетворяется наследованием одного или более назначенных инициализаторов от суперкласса.
Вспомогательные инициализаторы являются вторичными, поддерживающими инициализаторами для класса. Мы можем определить вспомогательный инициализатор для вызова назначенного инициализатора из того же класса, что и вспомогательный инициализатор с некоторыми параметрами назначенного инициализатора с установленными начальными значениями.
Вспомогательные инициализаторы не обязательны. Они нужны для того, чтобы наш код выглядел понятнее или чтобы сделать саму инициализацию класса более чистой и краткой.

### Синтаксис назначенных и вспомогательных инициализаторов

Назначенные инициализаторы для классов записываются точно так же как и простые инициализаторы для типов значений:

```
init(параметры) {
     выражения
}
```

Вспомогательные инициализаторы пишутся точно так же, но только дополнительно используется вспомогательное слово convenience, которое располагается до слова init и разделяется пробелом:

```
convenience init(параметры) {
     выражения
}
```

Для простоты отношений между назначенными и вспомогательными инициализаторами, Swift использует следующие три правила для делегирования вызовов между инициализаторами:
1. Назначенный инициализатор должен вызывать назначенный инициализатор из суперкласса.

```
class SuperClass {
    var someVar: Int
    
    init(someVar: Int) {
        self.someVar = someVar
    }
}

class ChildClass: SuperClass {
let someConst: Int

    init(someConst: Int, someVar: Int) {
        self.someConst = someConst
        super.init(someVar: someVar)
    }
}
```

2. Вспомогательный инициализатор должен вызывать другой инициализатор из того же класса.

```
class SuperClass {
    var someVar: Int
    
    init(someVar: Int) {
        self.someVar = someVar
    }
}

class ChildClass: SuperClass {
let someConst: Int

    init(someConst: Int, someVar: Int) {
        self.someConst = someConst
        super.init(someVar: someVar)
    }
    
    convenience init() {
        self.init(someConst: 12, someVar: 12)
    }
    
    convenience init(someConst: Int) {
        self.init(someConst: someConst, someVar: 12)
    }
}
```

3. Вспомогательный инициализатор в конечном счете должен вызывать назначенный инициализатор.

Вот как можно просто это запомнить:
* Назначенные инициализаторы должны делегировать наверх
* Вспомогательные инициализаторы должны делегировать по своему уровню (классу).

*Т.е вспомогательные инициализаторы могу вызывать внутри себя и делегировать только те инициализаторы, которые находятся в своем классе и все вспомогательные инициализаторы приводят к назначенному инициализатору. В то время как сами назначенные инициализаторы немогут в классах делегировать внутри себя другой назначенный инициализатор (в отличие от структур)*

### Двухфазная инициализация

Инициализация класса в Swift является двухфазным процессом. На первой фазе каждое свойство хранения получает начальное значение от класса, в котором оно представлено. Как только первоначальные значения для  свойств хранения были определены, начинается вторая фаза, и каждому классу предоставляется возможность изменить свои свойства еще до того как будет считаться, что созданный экземпляр можно использовать.
Использование двухфазного процесса инициализации делает инициализацию безопасной, в то же время обеспечивая полную гибкость классов в классовой иерархии. Двухфазная инициализация предотвращает доступ к значениям свойств до того, как они будут инициализированы и не допускает случайную установку значения свойства другим инициализатором.

Фаза первая
* Назначенный или вспомогательный инициализатор вызывается в классе.
* Память под новый экземпляр этого класса выделяется. Но она еще не инициализирована.
* Назначенный инициализатор для этого класса подтверждает, что все свойства, представленные этим классом, имеют значения. Память под эти свойства теперь инициализирована.
* Назначенный инициализатор передает инициализатору суперкласса, что пора проводить те же действия, только для его собственных свойств.
* Так продолжается по цепочке до самого верхнего суперкласса.
* После того как верхушка этой цепочки достигнута и последний класс в цепочке убедился в том, что все его свойства имеют значение, только тогда считается, что память для этого экземпляра полностью инициализирована. На этом первая фаза кончается.

Фаза вторая
* Двигаясь вниз по цепочке, каждый назначенный инициализатор в этой цепочке имеет такую возможность, как настраивать экземпляр. Теперь инициализаторы получают доступ к self и могут изменять свои свойства, создавать экземпляры и вызывать методы и т.д.
* И наконец, каждый вспомогательный инициализатор в цепочке имеет возможность настраивать экземпляр и работать с self.

### Наследование и переопределение инициализатора

Когда мы пишем инициализатор подкласса, который совпадает с назначенным инициализатором суперкласса, мы фактически переопределяем назначенный инициализатор. Таким образом мы должны писать модификатор override перед определением инициализатора подкласса. Это верно даже если мы переопределяем автоматически предоставляемый инициализатор.
Так же как и переопределенные свойства, методы или индексы, присутствие модификатора override подсказывает Swift проверить то, что суперкласс имеет совпадающий назначенный инициализатор, который должен быть переписан, и проверить параметры вашего переопределяющего инициализатора, чтобы они были определены так как и предполагалось.
Пример ниже определяет базовый класс Vehicle. Это базовый класс объявляет свойства numberOfWheels со значением 0 типа Int. Свойство numberOfWheels используется для вычисляемого свойства description, для создания описания характеристик транспортного средства типа String:

```
class Vehicle {
    var numberOfWheels = 0
    var description: String {
        return "\(numberOfWheels) колес(о)"
    }
}
```

Класс Vehicle предоставляет значение по умолчанию для его единственного свойства, и не имеет никаких собственных пользовательских инициализаторов. И в результате он автоматически получает дефолтный инициализатор. Дефолтный инициализатор (когда доступен) всегда является назначенным инициализатором для класса и может быть использован для создания нового экземпляра класса Vehicle с numberOfWheels равным 0:

```
let vehicle = Vehicle()
print("Транспортное средство \(vehicle.description)")
//Транспортное средство 0 колес(о)
```

Следующий пример определяет подкласс Bicycle суперкласса Vehicle:

```
class Bicycle: Vehicle {
    override init() {
        super.init()
        numberOfWheels = 2
    }
}
```

Подкласс Bicycle определяет пользовательский назначенный инициализатор init(). Назначенный инициализатор совпадает с назначенным инициализатором из суперкласса Vehicle и, таким образом, версия этого инициализатора класса Bicycle отмечена модификатором override.
Инициализатор init() для Bicycle начинается с вызова super.init(), который в свою очередь вызывает дефолтный инициализатор для суперкласса Vehicle класса Bicycle. Он проверяет, что унаследованное свойство numberOfWheels инициализировано в Vehicle, после чего у Bicycle появляется возможность его модифицировать. После вызова super.init() начальное значение numberOfWheels заменяется значением 2.

### Назначенные и вспомогательные инициализаторы в действии

Следующий пример показывает назначенные и вспомогательные инициализаторы, и автоматическое наследование инициализатора в действии. Этот пример определяет иерархию трех классов Food, RecipeIngredient и ShoppingListItem и демонстрирует как их инициализаторы взаимодействуют.
Основной (базовый) класс называется Food, который имеет одно простое свойство типа String, называемое name, и обеспечивает два инициализатора для создания экземпляров класса Food:

```
class Food {
    var name: String
    init(name: String) {
        self.name = name
    }
    convenience init() {
        self.init(name: "[Unnamed]")
    }
}
```

Классы по умолчанию не имеют почленного инициализатора, так что класс Food предоставляет назначенный инициализатор, который принимает единственный аргумент name. Этот инициализатор может быть использован для создания экземпляра Food со специфичным именем:

```
let namedMeat = Food(name: "Бекон")
//имя namedMeat является "Бекон"
```

Инициализатор init(name: String) из класса Food, представлен в виде назначенного инициализатора, потому что он проверяет, что все хранимые свойства нового экземпляра Food полностью инициализированы. Класс Food не имеет суперкласса, так что инициализатор init(name: String) не имеет вызова super.init() для завершения своей инициализации
Класс Food так же обеспечивает вспомогательный инициализатор init() без аргументов. Инициализатор init() предоставляет имя плейсхолдера для новой еды, делегируя к параметру name инициализатора init(name: String), давая ему значение [Unnamed] :

```
let mysteryMeat = Food()
//mysteryMeat называется "[Unnamed]"
```

Второй класс в иерархии - это подкласс RecipeIngredient класса Food. Класс RecipeIngredient создает модель ингредиентов в рецепте. Он представляет свойство quantity типа Int (в дополнение к свойству name, унаследованное от Food) и определяет два инициализатора для создания экземпляров RecipeIngredient:

```
class RecipeIngredient: Food {
    var quantity: Int
    init(name: String, quantity: Int) {
        self.quantity = quantity
        super.init(name: name)
    }
    override convenience init(name: String) {
        self.init(name: name, quantity: 1)
    }
}
```

Третий и последний класс в иерархии - подкласс ShoppingListItem класса RecipeIngredient. ShoppingListItem может создавать рецепты из ингредиентов, как только они появляются в листе покупок.
Каждый элемент в листе покупок (shopping list) начинается с “не куплен” или “unpurchased”.  ShoppingListItem имеет булево свойство purchased, со значением по умолчанию false. ShoppingListItem так же добавляет высчитываемое свойство description, которое предоставляет текстовое описание экземпляра ShoppingListItem:

```
class ShoppingListItem: RecipeIngredient {
    var purchased = false
    var description: String {
        var output = "\(quantity) x \(name)"
        output += purchased ? " ✔" : " ✘"
        return output
    }
}
```

Так как он предоставляет исходные значения для всех свойств, которые он представляет и не определяет никаких своих инициализаторов, то ShoppingListItem автоматически наследует все назначенные и вспомогательные инициализаторы из своего суперкласса.

## Проваливающиеся инициализаторы

Иногда бывает нужно определить класс, структуру или перечисление, инициализация которого может не сработать, провалиться. Такое неисполнение может быть вызвано некорректными значениями параметров или отсутствием требуемого внешнего источника данных или еще какое-нибудь обстоятельство, которое может не позволить завершить инициализацию успешно.
Для того чтобы справиться с условиями инициализации, которые могут провалиться, определите один или несколько проваливающихся инициализаторов как часть определения класса, структуры или перечисления. Мы можем написать проваливающийся инициализатор поместив вопросительный знак после ключевого слова init (init?).

*Мы не можем определить проваливающийся инициализатор и обычные инициализаторы с одними и теми же именами и типами параметров.*

Проваливающийся инициализатор создает опциональное значение типа, который он инициализирует. Мы пишем return nil внутри проваливающегося инициализатора для индикации точки, где инициализация может провалиться.

Пример ниже определяет структуру Animal, с константным свойством типа String с именем species. Структура Animal так же определяет проваливающийся инициализатор с одним параметром species. Этот инициализатор проверяет равняется ли переданное значение из  species в инициализатор пустой строке. Если строка действительно пустая, то возвращается nil, и срабатывает проваливающийся инициализатор. В противном случае значение свойства species установлено и инициализация проходит успешно.

```
struct Animal {
    let species: String
    init?(species: String) {
        if species.isEmpty { return nil }
        self.species = species
    }
}
```

Мы можем использовать этот проваливающий инициализатор для попытки инициализировать новый экземпляр структуры Animal и проверить успешно ли прошла инициализация:

```
let someCreature = Animal(species: "Жираф")
// someCreature имеет тип Animal?, но не Animal
 
if let giraffe = someCreature {
 print("Мы инициализировали животное типа \(giraffe.species) ")
}
// Выведет "Мы инициализировали животное типа Жираф "
```

Если мы передаем пустую строку в параметр species проваливающегося инициализатора, то инициализатор вызывает сбой инициализации:

```
let anonymousCreature = Animal(species: "")
// anonymousCreature имеет тип Animal?, но не Animal
 
if anonymousCreature == nil {
    print("Неизвестное животное не может быть инициализировано")
}
 
// Выведет "Неизвестное животное не может быть инициализировано"
```

### Проваливающиеся инициализаторы для перечислений

Мы можем использовать проваливающийся инициализатор для выбора подходящего члена перечисления основываясь на одном или более параметров. Инициализатор может провалиться, если предоставленные параметры не будут соответствовать подходящему члену перечисления.
Пример ниже определяет перечисление TemperatureUnit с тремя возможными вариантами (kelvin, celsius и fahrenheit). Проваливающийся инициализатор используется для того, чтобы найти подходящий член перечисления для значения типа Character, которое представляет символ температуры:

```
enum TemperatureUnit {
    case kelvin, celsius, fahrenheit
    init?(symbol: Character) {
        switch symbol {
        case "K":
            self = .kelvin
        case "C":
            self = .celsius
        case "F":
            self = .fahrenheit
        default:
            return nil
        }
    }
}
```

Мы можем использовать этот проваливающийся инициализатор для выбора соответствующего члена из трех возможных состояний и вызвать провал инициализации, если параметр не соответствует этим состояниям:

```
let fahrenheitUnit = TemperatureUnit(symbol: "F")
if fahrenheitUnit != nil {
  print("Эта единица измерения температуры определена, а значит наша инициализация прошла успешно!")
}
 
// Выведет "Эта единица измерения температуры определена, а значит наша инициализация прошла успешно!"
 
let unknownUnit = TemperatureUnit(symbol: "X")
if  unknownUnit == nil {
  print("Единица измерения температуры не определена, таким образом мы зафейлили инициализацию")
}
 
// Выведет "Единица измерения температуры не определена, таким образом мы зафейлили инициализацию"
```

### Проваливающиеся инициализаторы для перечислений с начальными значениями

Перечисления с начальными значениями по умолчанию получают проваливающийся инициализатор init?(rawValue: ), который принимает параметр rawValue подходящего типа и выбирает соответствующий член перечисления, если он находит подходящий, или срабатывает сбой инициализации, если существующее значение не находит совпадения среди членов перечисления.

```
enum TemperatureUnit: Character {
  case kelvin = "K", celsius = "C", fahrenheit = "F"
}
 
let fahrenheitUnit = TemperatureUnit(rawValue: "F")
if fahrenheitUnit != nil {
  print("Эта единица измерения температура определена, а значит наша инициализация прошла успешно!")
}
 
// Выведет "Эта единица измерения температура определена, а значит наша инициализация прошла успешно!"
 
let unknownUnit = TemperatureUnit(rawValue: "X")
if  unknownUnit == nil {
  print("Единица измерения температуры не определена, таким образом мы зафейлили инициализацию.")
}
 
// Выведет "Единица измерения температуры не определена, таким образом мы зафейлили инициализацию."
```

### Распространение проваливающегося инициализатора

Проваливающийся инициализатор класса, структуры, перечисления может быть делегирован к другому проваливающемуся инициализатору из того же класса, структуры, перечисления. Аналогично проваливающийся инициализатор подкласса может быть делегирован наверх в проваливающийся инициализатор суперкласса.
Если мы делегируем другому инициализатору, который проваливает инициализацию то и весь процесс инициализации проваливается немедленно за ним, и далее никакой код инициализации уже не исполняется.
Пример ниже определяет подкласс CartItem класса Product. CartItem создает модель элемента в корзине онлайн заказа. CartItem представляет свойство хранения quantity и проверяет, чтобы это свойство всегда имело значение не менее 1:

```
class Product {
    let name: String
    init?(name: String) {
        if name.isEmpty { return nil }
        self.name = name
    }
}
 
class CartItem: Product {
    let quantity: Int
    init?(name: String, quantity: Int) {
        if quantity < 1 { return nil }
        self.quantity = quantity
        super.init(name: name)
    }
}
```

Проваливающийся инициализатор для CartItem начинается с того, что получает значение quantity 1 или более. Если значение quantity некорректное, то вся инициализация проваливается и код дальше не исполняется. Так же проваливающийся инициализатор Product проверяет значение свойства name, и если оно равно пустой строке, то инициализация немедленно прекращается.

## Требуемые инициализаторы

Если мы хотим, чтобы каждый подкласс реализовывал определенный инициализатор, мы должны написать ключевое слово required перед init:

```
class SomeClass {
    required init() {
      //пишем тут реализацию инициализатора
    }
}
```

Мы также должны писать модификатор required перед каждой реализацией требуемого инициализатора класса для индикации того, что последующий подкласс так же должен унаследовать этот инициализатор по цепочке. Мы не пишем override, когда переопределяем требуемый инициализатор:

```
class SomeSubclass: SomeClass {
    required init() {
      //пишем тут реализацию инициализатора подкласса
    }
}
```

## Начальное значение свойства в виде функции или замыкания

Если начальное значение свойства требует какой-то настройки или структуризации, то мы можете использовать замыкание или глобальную функцию, которая будет предоставлять значение для этого свойства. Как только создается новый экземпляр, вызывается функция или замыкание, которая возвращает значение, которое присваивается в качестве начального значения свойства.
Ниже приведена схема того, как замыкание может предоставлять начальное значение свойству:

```
class SomeClass {
    let someProperty: SomeType = {
      // создаем начальное значения для SomeProperty внутри этого замыкания
      // someValue должен быть того же типа, что и SomeType
      return someValue
    }()
} 
```

*Если мы используем замыкание для инициализации свойства, нужно помнить, что остальная часть экземпляра еще не инициализирована, на тот момент когда исполняется замыкание. Это значит, что мы не можем получить доступ к значениям других свойств из нашего замыкания, даже если эти свойства имеют начальное значение. Мы так же не можем использовать неявное свойство self и не можете вызвать какой-либо метод вашего экземпляра.*
