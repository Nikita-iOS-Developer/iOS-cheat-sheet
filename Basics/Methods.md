# Методы

Методы - это функции, которые связаны с определенным типом. Классы, структуры и перечисления - все они могут определять методы экземпляра, которые включают в себя определенные задачи и функциональность для работы с экземпляром данного типа. Классы, структуры и перечисления так же могут определить методы типа, которые связаны с самим типом.

## Методы экземпляра

Методы экземпляра являются функциями, которые принадлежат экземплярам конкретного класса, структуры или перечисления. Они обеспечивают функциональность этих экземпляров, либо давая возможность доступа и изменения свойств экземпляра, либо обеспечивая функциональность экземпляра в соответствии с его целью. Методы экземпляра имеют абсолютно одинаковый синтаксис как и функции.
Мы пишем метод экземпляра внутри фигурных скобок типа, которому он принадлежит. Метод экземпляра имеет неявный доступ ко всем остальным методам экземпляра и свойствам этого типа. Метод экземпляра может быть вызван только для конкретного экземпляра типа, которому он принадлежит. Его нельзя вызвать в изоляции, без существующего экземпляра.
Ниже пример, который определяет простой класс Counter, который может быть использован для счета количества повторений действия:

```
class Counter {
    var count = 0
    func increment() {
        count += 1
    }
    func increment(by amount: Int) {
        count += amount
    }
    func reset() {
        count = 0
    }
}
```

## Свойство self

Каждый экземпляр типа имеет неявное свойство self, которое является абсолютным эквивалентом самому экземпляру. Вы используете свойство self для ссылки на текущий экземпляр, внутри методов этого экземпляра.
Метод increment может быть вызван так:

```
func increment() {
    self.count += 1
}
```

## Изменение типов значений методами экземпляра

Структуры и перечисления являются типами значений. По умолчанию, свойства типов значений не могут быть изменены изнутри методов экземпляра.
Однако, если нам нужно изменить свойства вашей структуры или перечисления изнутри конкретного метода, то мы можем выбрать поведение как изменяющее для этого метода. После этого метод может изменить свои свойства изнутри метода, и все изменения будут сохранены в исходную структуру, когда выполнение метода закончится. Метод так же может присвоить совершенно новый экземпляр для свойства self, и этот новый экземпляр заменит существующий, после того как выполнение метода закончится.
Мы можем все это осуществить, если поставим ключевое слово mutating перед словом func для определения метода:

```
struct Point {
   var x = 0.0, y = 0.0
   mutating func moveBy(x deltaX: Double, y deltaY: Double) {
      x += deltaX
      y += deltaY
   }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
print("Сейчас эта точка на (\(somePoint.x), \(somePoint.y))")
// Выведет "Сейчас эта точка на (3.0, 4.0)"
```

*Мы не можем вызывать изменяющий метод для константных типов структуры, потому как ее свойства не могут быть изменены, даже если свойства являются переменными.*

## Присваивание значения для self внутри изменяющего метода

Изменяющие методы могут присваивать полностью новый экземпляр неявному свойству self. Пример Point, приведенный выше, мог бы быть записан в такой форме:

```
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
}
```

Такая версия изменяющего метода moveBy(x:y:) создает абсолютно новую структуру, чьим значениям x, y присвоены значения конечной точки. Конечный результат вызова этой альтернативной версии метода будет абсолютно таким же как и в ранней версии.
Изменяющие методы для перечислений могут установить отдельный член перечисления как неявный параметр self:

```
enum TriStateSwitch {
    case off, low, high
    mutating func next() {
        switch self {
        case .off:
            self = .low
        case .low:
            self = .high
        case .high:
            self = .off
        }
    }
}
var ovenLight = TriStateSwitch.low
ovenLight.next()
// ovenLight равен .high
ovenLight.next()
// ovenLight равен .off
```
### Явные и неявные свойства

Основное отличие между явными и неявными свойствами в Swift заключается в том, как они хранят и предоставляют доступ к данным.
1. Явные свойства:
   - Явные свойства представляют собой хранимые свойства, которые хранят конкретные значения.
   - Доступ к явным свойствам осуществляется напрямую через имя свойства.
   - Пример: var name: String

2. Неявные свойства:
   - Неявные свойства могут быть вычисляемыми свойствами, которые вычисляются на основе других свойств или операций.
   - Доступ к неявным свойствам осуществляется так же, как и к явным свойствам, но значение вычисляется динамически при каждом обращении.
   - Пример: 
   
```
     var area: Double {
         return width * height
     }
     
```
Использование явных и неявных свойств зависит от конкретной задачи. Явные свойства удобны для хранения конкретных данных, в то время как неявные свойства могут быть полезны для вычисления значений на основе других данных.

## Методы типа

Методы экземпляра, которые описаны выше, являются методами, которые вызываются экземпляром конкретного типа. Мы так же можем определить методы, которые вызываются самим типом. Такие методы зовутся методами типа. Индикатор такого метода - ключевое слово static, которое ставится до ключевого слова метода func. Классы так же могут использовать ключевое слово class, чтобы разрешать подклассам переопределение инструкций суперкласса этого метода.

