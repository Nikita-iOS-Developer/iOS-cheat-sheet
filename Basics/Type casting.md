# Приведение типов

Привидение типов - это способ проверить тип экземпляра и/или способ обращения к экземпляру так, как если бы он был экземпляром суперкласса или подкласса откуда-либо из своей собственной классовой иерархии.
Приведение типов в Swift реализуется с помощью операторов is и as. Эти два оператора предоставляют простой и выразительный способ проверки типа значения или преобразование значения к другому типу.
Мы также можете использовать приведение типов для проверки соответствия типа протоколу.

## Определение классовой иерархии для приведения типов

Мы иожем использовать привидение типов с иерархией классов и подклассов, чтобы проверить тип конкретного экземпляра класса и преобразовать тип этого экземпляра в тип другого класса в той же иерархии. Следующих три фрагмента кода определяют иерархию классов и массив, который содержит экземпляры этих классов, для использования в примере приведения типов.
Первый фрагмент кода определяет новый базовый класс MediaItem. Этот класс предоставляет базовую функциональность для любого вида элемента, который появляется в цифровой медиа библиотеке. А именно, он определяет свойство name типа String и инициализатор init name. (В этом примере считается, что все фильмы, песни или другие медиа штуковины имеют свойство name или попросту имя.):

```
class MediaItem {
    var name: String
    init(name: String) {
        self.name = name
    }
}
```

Следующий фрагмент определяет два подкласса класса MediaItem. Первый подкласс - Movie, он инкапсулирует дополнительную информацию о фильмах. Он добавляет свойство director поверх базового класса MediaItem с соответствующим инициализатором. Второй подкласс - Song. Этот подкласс добавляет свойство artist и инициализатор поверх базового класса:

```
class Movie: MediaItem {
    var director: String
    init(name: String, director: String) {
        self.director = director
        super.init(name: name)
    }
}
 
class Song: MediaItem {
    var artist: String
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}
```

Последний отрывок кода создает неизменяемый массив library, который содержит два экземпляра Movie и три экземпляра Song. Тип library выведен во время инициализации массива литералом массива. Механизм проверки типов Swift делает вывод, что Movie, Song имеют общий суперкласс MediaItem, так что тип массива library становится [MediaItem]:

```
let library = [
    Movie(name: "Casablanca", director: "Michael Curtiz"),
    Song(name: "Blue Suede Shoes", artist: "Elvis Presley"),
    Movie(name: "Citizen Kane", director: "Orson Welles"),
    Song(name: "The One And Only", artist: "Chesney Hawkes"),
    Song(name: "Never Gonna Give You Up", artist: "Rick Astley")
]
// тип "library" выведен как [MediaItem]
```

Элементы, которые хранятся в library все еще экземпляры Movie и Song на самом деле. Однако, если мы переберем элементы массива, то они все будут одного типа MediaItem, а не Movie или Song. Для того чтобы работать с ними как с исходными типами, нам нужно проверить их типы или привести к другому типу.

## Проверка типа

Мы используем оператор проверки типа (is) для проверки того, соответствует ли тип экземпляра типам какого-то определенного подкласса. Оператор проверки типа возвращает true, если экземпляр имеет тип конкретного подкласса, false, если нет.
Пример ниже определяет две переменные movieCount и songCount, которые считают число экземпляров Movie и экземпляров Song в массиве library:

```
var movieCount = 0
var songCount = 0
 
for item in library {
    if item is Movie {
        movieCount += 1
    } else if item is Song {
        songCount += 1
    }
}
 
print("В Media библиотеке содержится \(movieCount) фильма и \(songCount) песни")
// Выведет "В Media библиотеке содержится 2 фильма и 3 песни"
```

Пример перебирает все элементы массива library. На каждую итерацию цикла for-in константа item инициализируется следующим значением типа MediaItem из массива library.
Выражение item is Movie возвращает true, в том случае, если текущий item типа MediaItem является экземпляром Movie, и это выражение возвращает false, если не является экземпляром Movie. Аналогично item is Song проверяет является ли item экземпляром Song. В конце цикла for-in значения movieCount и songCount содержат количество экземпляров MediaItem каждого типа.

## Понижающее приведение

Константа или переменная определенного класса может фактически ссылаться на экземпляр подкласса. Там, где мы считаем, что это тот случай, мы можем попробовать привести тип к типу подкласса при помощи оператора понижающего приведения (as? или as!).
Из-за того, что понижающее приведение может провалиться, оператор приведения имеет две формы. Опциональная форма (as?), которая возвращает опциональное значение типа, к которому мы пытаемся привести. И принудительная форма (as!), которая принимает попытки понижающего приведения и принудительного разворачивания результата в рамках одного составного действия.
Используем опциональную форму оператора понижающего приведения (as?), когда мы не уверены, что наше понижающее приведение выполнится успешно. В этой форме оператор всегда будет возвращать опциональное значение, и значение будет nil, если понижающее приведение будет не выполнимо. Так же это позволяет вам проверить успешность понижающего приведения типа.
Используем принудительную форму оператора понижающего приведения (as!), но только в тех случаях, когда мы точно уверены, что понижающее приведение будет выполнено успешно. Эта форма оператора вызовет ошибку исполнения, если мы попытаемся таким образом привести к некорректному типу класса.
Пример ниже перебирает элементы MediaItem в массиве library и выводит соответствующее описание для каждого элемента. Чтобы сделать это, ему нужно получить доступ к каждому элементу как Movie или Song, а не просто как к MediaItem. Это необходимо для того, чтобы был доступ к свойствам director, artist, которые пригодятся нам в описании.
В этом примере каждый элемент массива может быть либо Movie, либо Song. Мы не знаем наперед какой класс нам нужно использовать для каждого элемента, так что логично будет использовать опциональную форму оператора понижающего приведения (as?) для проверки возможности понижающего приведения к конкретному подклассу конкретного элемента массива:

```
for item in library {
    if let movie = item as? Movie {
        print("Movie: \(movie.name), dir. \(movie.director)")
    } else if let song = item as? Song {
        print("Song: \(song.name), by \(song.artist)")
    }
}
 
// Movie: Casablanca, dir. Michael Curtiz
// Song: Blue Suede Shoes, by Elvis Presley
// Movie: Citizen Kane, dir. Orson Welles
// Song: The One And Only, by Chesney Hawkes
// Song: Never Gonna Give You Up, by Rick Astley
```

Пример начинается с попытки понижающего приведения текущего элемента item в качестве Movie. Так как item является экземпляром MediaItem, то этот элемент может быть Movie, но он также может быть и Song или даже просто базовым MediaItem. Из-за этой неопределенности мы и используем опциональную форму оператора (as?). Результат выражения item as? Movie является тип Movie? или “опциональный Movie”
Понижающее приведение к Movie проваливается, когда оно применимо к экземплярам Song в массиве library. Объединив это все, мы получаем, что пример выше использует опциональную привязку для проверки наличия значения у опционального Movie (то есть, чтобы выяснить успешность проведенной операции). Опциональная привязка записана выражением вида “if let movie = item as? Movie”, что может быть прочитано так:
“Пробуем получить доступ к item в качестве Movie. Если доступ успешен, то присвоим временную константу movie значение, которое мы получили из опционального Movie.”
Если понижающее приведение прошло успешно, то свойства movie используются в качестве вывода описания для экземпляра Movie, включая имя director. Аналогичный принцип используется при проверке экземпляров Song и при выводе описания (включая имя artist), как только находится элемент Song в массиве library.
